<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Javascript Cheat Sheet</title>

    <style>
        body {
            padding: 0;
            margin: 0;
            margin-bottom: 4rem;
            box-sizing: border-box;
            font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;
            /* font-family:Verdana, Geneva, Tahoma, sans-serif */
            position: relative;
        }

        h1,
        h3 {
            text-align: center;
            font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;
            text-decoration: underline;
        }

        table {
            border-collapse: collapse;
            width: 100%;
        }

        table.container {
            width: 90%;
            margin: 0 auto;
        }

        span {
            background-color: yellow;
        }




        table.section {
            border: 2px solid black;
            background-color: rgb(249, 250, 176);
            font-size: 13px;
        }

        .section thead {
            color: black;
            background-color: #aabdfd;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            text-align: center;
            text-decoration: underline;
            font-weight: 700;
            border: 2px solid black;
        }

        .section thead td {
            border: 2px solid black;
        }

        .section tbody td {
            border-right: 2px solid black;
            border-bottom: 1px solid black;
            padding: 7px;
        }

        .section tbody td:nth-child(2) {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            /* font-size: large; */
        }

        .nav-links {
            /* display: flex; */
        }

        .nav-links a {
            text-decoration: none;
            color: black;
        }

        .nav-links a:hover {
            color: blueviolet;
        }

        a {
            color: blueviolet;
        }

        .to-top {
            color: black;
            position: fixed;
            right: 0;
            top: 10px;
            font-size: smaller;
            background: #aabdfd;
            padding: 10px;
            border-radius: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 40px;
            width: 40px;
            border: 1px solid #000;
        }

        @media screen and (max-width:600px) {
            h1 {
                font-size: 20px;
            }

            .center-flex {
                display: flex;
                justify-content: center;
            }
        }
    </style>

</head>
<!-- 
   &lt;  === <
     &emsp;  === big space
-->

<body>
    <div class="center-flex">
        <h1>Javascript Cheat sheet & Snippits</h1>
    </div>
    <nav id="top">
        <ul class="nav-links">
            <li><a href="#DOM">DOM</a></li>
            <li><a href="#DS">Data Structures, Modern Operators and Strings</a></li>
            <li><a href="#numbers">Numbers, Dates, Intl and Timers </a></li>
            <li><a href="#functions">Functions</a></li>
            <li><a href="#OOP">Object Orientated Programming (OOP)</a></li>
            <li><a href="#async">Asynchronous JavaScript</a></li>
            <li><a href="#modules">Modules and tooling</a></li>
            <li><a href="#BOM">BOM</a></li>
            <li><a href="#regEX">regEX</a></li>
            <li><a href="#error-handling">Error Handling</a></li>
            <li><a href="#handy">Handy stuff / Other</a></li>
        </ul>
    </nav>
    <a class="to-top" href="#top">Top &#8593;</a>
    <table class="container">
        <!-- DOM API and event fundamentals -->
        <tr>
            <td>
                <table class="section">
                    <caption>
                        <h3 class="DOM">DOM API and event fundamentals</h3>
                    </caption>
                    <thead>
                        <tr>
                            <td>Code</td>
                            <td>Description</td>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>The DOM is not part of Javascript, It is part of the JavaScript Web APIs, web APIs are libraries we can access from our JavaScript code <br>
                                JavaScript uses inline css, on the html page rather than manipulate the css document </td>
                            <td>What's the DOM and DOM Manipulation</td>
                        </tr>
                        <tr>
                            <td> window.pageYOffset | window.pageYOffset <span>Old way to find How far top of the window is / how far we
                                    have scrolled from the top</span> <br>

                                window.scrollX, window.scrollY are the new ways that replaced window.pageYOffset and window.pageXOffset <br>
                                console.log('Current Scroll (X/Y)', window.scrollX, window.scrollY);
                                <br>
                                element.offsetTop, <span> How far the element is from the top</span> <br><br>
                                let find_All_dimensions = <b> element.getBoundingClientRect(); </b> <span>find out all
                                    dimensions</span> <br> <br>

                                let width = window.innerWidth; <br> <br>
                                let height = window.innerHeight; <br><br>
                                document.documentElement.clientHeight,<br>
                                document.documentElement.clientWidth<br>

                            </td>
                            <td> Find out dimensions in relation to window and elements / top of page</td>
                        </tr>
                        <tr>
                            <td>
                                We can think of .closest as the opposite to the querySelector, as the querySelector with go down the tree searching children till <br>
                                it finds the element we select .closest will go up the tree till it finds a match on the parents. <br><br>

                                h1.closest('.header').style.background = 'var(--gradient-secondary)'; // selects the closest element to the class reference
                                <br><br>
                                h1.closest('h1').style.background = 'var(--gradient-primary)'; will also select itself <br><br>

                                <span><b> .closest in action, for eventDelegation.</b></span><br>

                                tabsContainer.addEventListener('click', function (e) {<br>
                                &emsp;const clicked = e.target.closest('.operations__tab');<br>
                                &emsp;console.log(clicked);<br> <br>

                                &emsp; // Guard clause<br>
                                &emsp; if (!clicked) return;<br>

                                &emsp; clicked.classList.add('operations__tab--active');<br>
                                });<br><br>

                                <span>the guard clause is a newer way of writing</span><br>

                                if(clicked){<br>
                                &emsp; // run this code<br>
                                }<br><br>
                                This prevents errors in the console when the element doesn't exist etc.
                            </td>
                            <td>The '.closest' method</td>
                        </tr>
                        <tr>
                            <td>
                                <br> 1. Add the event listener to a common parent element
                                <br> 2. Determine what element originated the event <br><br>

                                <br>document.querySelector('.nav__links').addEventListener('click', function (e) {
                                <br>&emsp;console.log(e.target);
                                <br>&emsp;if (e.target.classList.contains('nav__link')) {
                                <br>&emsp;&emsp; e.preventDefault();
                                <br>&emsp;&emsp;const id = e.target.getAttribute('href');
                                <br>&emsp;&emsp;document.querySelector(id).scrollIntoView({ behavior: 'smooth' });
                                <br>&emsp;}
                                <br>});

                                <br><br>
                                This is a lot more efficient than adding the same function / event handler to multiple elements. <br>
                                We add the event listener on the parent and then select the children based on a condition that the target meets. <br><br>
                                This is called the "matching strategy".

                                <br><br>

                                This is needed for elements that are not yet included on the page when it loads (ones added with Javascript). <br>
                                And this how we would addEventListeners to them
                            </td>
                            <td>Event delegation <br>
                                The strategy for EventListener.</td>
                        </tr>
                        <tr>
                            <td>window.addEventListener('scroll', navScroll); &emsp; It is just scroll for the event
                                listener. <br> <br>
                                &lt; div onscroll="myFunction()">&lt;/div> <br> <br>
                                object.onscroll = function(){myScript}; <br> <br>

                                <b> resize works the same </b> <br>
                                window.addEventListener('resize', navresize); &emsp; It is just resize for the event
                                listener. <br> <br>


                            </td>
                            <td> Get some thing to happen on Scroll, Scroll events </td>
                        </tr>
                        <tr>
                            <td> const kiddyArray = Array.from(%Element%.children);</td>
                            <td>Create and array from all of an elements child items</td>
                        </tr>
                        <tr>
                            <td> The simplest method to trigger CSS animations is by adding or removing a class -</td>
                            <td>Starting an animation in Javascript</td>
                        </tr>

                        <tr>
                            <td>
                                <u><strong> classList </strong></u> <br><br>
                                Use add() and remove() to add CSS classes to and remove CSS classes from the class list
                                of an element. <br> <br>
                                div.classList.remove('block','red'); <br> <br>
                                div.classList.add('info','visible','block'); <br> <br>
                                div.classList.replace('info','warning'); <br> <br>
                                div.classList.toggle('on');
                            <td>
                                How to add or remove classes <br> <br>

                                Using <strong>"classList" </strong> , you can add or remove a class without affecting
                                any others the element may have. <br>
                                But if you assign "className", it will wipe out any existing classes while adding the
                                new one (or if you assign an empty string it will wipe out all of them). <br> <br>

                                Assigning "className" can be a convenience for cases where you are certain no other
                                classes will be used on the element, <br>
                                I would normally <strong> use the "classList" methods exclusively. </strong>

                                <br><br>
                                When we need to change multiple styles on the page for one element, it is best to add a class then import the styles from this class
                                <br> and add/remove when its needed, Rather than writing lots of code.
                            </td>
                        </tr>

                        <tr>
                            <td>li.getAttribute('href'); &emsp; // returns the value of the href <br>
                                li.setAttribute('href', &emsp; 'https://google.com'); // sets the href (adds attributes)
                                <br>
                                li.hasAttribute('name') &emsp;// returns bool<br>
                                <br><br>
                                In JavaScript, you can use the setAttribute() method to define attributes to an element. <br>
                                <b>Using the same method, you can override the !important property of an element.</b> <br>
                                <span> ele.setAttribute ('style', 'display: block !important;');</span>
                            </td>
                            <td>Get,set, remove attributes</td>
                        </tr>
                        <tr>
                            <td>Select the Parent Element.
                                Use one of the firstChild, childNodes.length, children.length property to find whether
                                element has child or not. <br>
                                hasChildNodes() method can also be used to find the child of the parent node.</td>
                            <td>How to check if an element has any children in JavaScript ?</td>
                        </tr>
                        <tr>
                            <td>

                                <br>
                                element.children &emsp; <span><u> returns only elements as HTMLCollection, and is easier
                                        for selecting elements, you will need to convert to array to run forEach and
                                        higher order array function </u></span> <br>
                                element.previousElementSibling <br>
                                element.nextElementSibling<br>
                                element.firstElementChild; <br>
                                element.lastElementChild;<br>
                                <br> <br>
                                <span><u> return lines breaks as nodes and also comments </u></span> <br>
                                element.childNodes <br>
                                element.firstChild; <br>
                                element.lastChild; <br>

                                <br> <br>

                                <span>z-index will always be higher on a parent element, you will have to make it a
                                    sibling for z-index to take effect, this is crucial when making a mobile
                                    submenu!</span>

                            </td>
                            <td>Sibling Selection / DOM traversal</td>
                        </tr>
                        <tr>
                            <td>
                                <span><b>Going downwards: child</b></span> <br>
                                console.log(h1.querySelectorAll('.highlight'));<br>
                                console.log(h1.childNodes); // gets everything<br>
                                console.log(h1.children); // only direct children elements<br>
                                console.log((h1.firstElementChild.style.color = 'red'));<br>
                                console.log((h1.lastElementChild.style.color = 'yellow'));<br><br>

                                <span><b>Going upwards: parents</b></span> <br>
                                console.log(h1.parentNode);<br>
                                console.log(h1.parentElement);<br><br>

                                <span><b>Going sideways: siblings</b></span> <br>

                                console.log(h1.previousElementSibling);<br>
                                console.log(h1.nextElementSibling);<br>
                                console.log(h1.previousSibling);<br>
                                console.log(h1.nextSibling);<br><br>

                                <span><b>Get all siblings (select the parent element then all children)</b></span> <br>
                                console.log(h1.parentElement.children);</td>
                            <td>Sibling Selection / DOM traversal</td>
                        </tr>
                        <tr>
                            <td>targetElement.insertAdjacentElement(position, element); <br> <br>
                                position
                                A DOMString representing the position relative to the targetElement; must match (case-insensitively) one of the following strings: <br>
                                'beforebegin': Before the targetElement itself. <br>
                                'afterbegin': Just inside the targetElement, before its first child. <br>
                                'beforeend': Just inside the targetElement, after its last child. <br>
                                'afterend': After the targetElement itself. <br> <br>

                                element <br>
                                The element to be inserted into the tree. <br> <br>

                                <span> beforebegin</span><br>
                                &lt;p> <br> <br>
                                <span> afterbegin </span> <br>
                                foo <br>
                                <span> beforeend </span> <br><br>
                                &lt;/p> <br>
                                <span> afterend </span> <br> <br>
                                <b> Note: The beforebegin and afterend positions work only if the node is in a tree and has an element parent. </b>
                            </td>
                            <td>The insertAdjacentElement() method of the Element interface inserts a given element node at a given position relative to the element it is invoked upon.</td>
                        </tr>
                        <tr>
                            <td>const mobileListItems = Array.from(mobile_ul.children); <br> <br>
                                const allSlides = [...document.querySelectorAll('carousel__item')]; <span>// using the
                                    spread operator; </span>
                            </td>
                            <td>Convert HTMLCollection to an Array</td>
                        </tr>
                        <tr>
                            <td>
                                var elt = document.getElementById('foo'); <br>
                                console.log(elt.nodeName); <br> Note that nodeName returns the element name capitalized
                                and without the angle brackets, <br><br> which means that if you want to check if an
                                element is an &lt;div> element you could do it as follows: <br>

                                <span>elt.nodeName == "DIV" </span>

                            </td>
                            <td> How can I determine the type of an HTML element in JavaScript? <br> <strong>
                                    nodeName</strong> is the attribute you are looking for. check example on left <br>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                textContent and innerHTML are similar, but
                                <ul>
                                    <li>
                                        innerHTML will return everything HTML tags included, <br>
                                    </li>
                                    <li>
                                        textContent will just return the text
                                    </li>
                                </ul>
                            </td>
                            <td>
                                textContent VS innerHTML
                            </td>
                        </tr>
                        <tr>
                            <td>In an eventHandler the 'this' element always points to the element which the handler was attached to</td>
                            <td>The 'this' keyword</td>
                        </tr>
                        <tr>
                            <td>The <span>mouseover / mouseout </span> event triggers when the mouse pointer enters the
                                parent element, and its child elements. <br><br>

                                The <span>mouseenter / mouseleave </span> event is only triggered when the mouse pointer
                                enters the parent element. <br>

                                Every time you enter a child its classified as you going "mouseout" when you come out of
                                the child element you are back "mouseover"</td>
                            <td>Difference between mouseenter/mouseleave & mouseover/mouseout .</td>
                        </tr>
                        <tr>
                            <td>
                                <br>
                                auxclick &emsp;| &emsp;
                                blur &emsp;| &emsp;
                                click &emsp;| &emsp;
                                dblclick &emsp;| &emsp;
                                compositionend &emsp;| &emsp;
                                compositionstart &emsp;| &emsp;
                                compositionupdate <br> <br>
                                contextmenu &emsp;| &emsp;
                                copy &emsp;| &emsp;
                                cut &emsp;| &emsp;
                                paste &emsp;| &emsp;
                                <br> <br>
                                error &emsp; | &emsp;
                                focus &emsp;| &emsp;
                                focusin &emsp;| &emsp;
                                focusout &emsp;| &emsp; <br> <br>
                                fullscreenchange &emsp;| &emsp;
                                fullscreenerror &emsp;| &emsp;
                                keydown &emsp;| &emsp;
                                keypress &emsp;| &emsp;
                                keyup &emsp;| &emsp; <br> <br>
                                mousedown &emsp;| &emsp;
                                mouseenter &emsp;| &emsp;
                                mouseleave &emsp;| &emsp;
                                mousemove |<br> <br>
                                mouseout &emsp;| &emsp;
                                mouseover &emsp;| &emsp;
                                mouseup &emsp;| &emsp; <br> <br>
                                overflow &emsp;| &emsp;
                                scroll &emsp;| &emsp;
                                select &emsp;| &emsp; <br> <br>
                                touchcancel &emsp;| &emsp;
                                touchend &emsp;| &emsp;
                                touchmove &emsp;| &emsp;
                                touchstart &emsp;| &emsp;
                                wheel</td>
                            <td>Events</td>

                        </tr>
                        <tr>
                            <td>
                                if (e.key === "Escape" && !overlay.classList.contains('hidden')) <br>
                                &emsp; closeModal(); <br><br>

                                // is the same as <br>

                                if (e.key === "Escape") { <br>
                                &emsp; if (!overlay.classList.contains('hidden')) closeModal(); <br>
                                }

                                <br><br>
                                keyboard/press events are global and are added to document.addEventListener('keydown', function) <br><br>

                                keypress, &emsp; - fires continuously when we press the button, so we usually use either <span>keydown</span> or keyup but mostly keydown

                                <br><br>
                                Listening to 'submit' on a form will handle click and enter although enter also counts as a click.
                            </td>
                            <td>Handling an "Esc" Keypress Event<br>
                                We should add an escape keydown to close a modal as well as a click</td>
                        </tr>
                        <tr>
                            <td>console.log(getComputedStyle(message).width);</td>
                            <td>
                                Get computed style of any element
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <b><span>Old way For removing one element:</span></b> <br><br>

                                var elem = document.getElementById("yourid");<br>
                                elem.parentElement.removeChild(elem);<br><br>

                                <b><span>For removing all the elements with for example a certain class name:</span> </b><br><br>

                                var list = document.getElementsByClassName("yourclassname");<br>
                                for(var i = list.length - 1; 0 <= i; i--)<br>
                                    &emsp; if(list[i] && list[i].parentElement)<br>
                                    &emsp;&emsp; list[i].parentElement.removeChild(list[i]);

                                    <br><br>

                                    <b><span>New way that replaces having to select parents. (not IE compatible)</span></b><br>
                                    document.querySelector('.btn--close-cookie').remove();
                                    });
                            </td>
                            <td>Removing elements</td>
                        </tr>
                        <tr>
                            <td>
                                <span>We call them like this in JavaScript</span><br>
                                icon.style.fill =
                                window.getComputedStyle(document.documentElement).getPropertyValue('--colorBlue');
                                <br><br>

                                <span> here is how we can change their value</span> <br>
                                document.documentElement.style.setProperty('--color-font-general', '#000');
                                <br> <br>
                                Note that the value returned has the leading space, so you would get " #336699" instead
                                of "#336699". <br>
                                This matters if you are trying to check the value (it may not match
                                because of that leading space, so consider trimming it before checking).
                            </td>
                            <td> <strong>Calling Custom CSS variables</strong> </td>
                        </tr>
                        <tr>
                            <td>getComputedStyle can pull style info from pseudo-elements (such as ::after, ::before, ::marker, <br><br>

                                var h3 = document.querySelector('h3');<br>
                                var result = getComputedStyle(h3, ':after').content;<br><br>

                            </td>
                            <td>Using Window.getComputedStyle() to get the value of a pseudoElement</td>
                        </tr>
                        <tr>
                            <td>links with a href of "#" will automatically make the page jump to the top when clicked. <br><br>

                                We can prevent this default behavior with javascript, click handler, e.preventDefault();</td>
                            <td>Custom links with a href of "#" or just custom links</td>
                        </tr>
                        <tr>
                            <td>document.getElementsByTagName, & document.getElementsByClassName return a HTMLCollection. <br>
                                This is different to a nodelist as it updates itself automatically when if we delete one its nodes from the DOM <br><br>

                                <b>Live vs. Static NodeLists</b><br>
                                Although they are both considered NodeLists, there are 2 varieties of NodeList: live and static.<br><br>

                                <u>Live NodeLists</u> <br>
                                In some cases, the NodeList is live, which means that changes in the DOM automatically update the collection.<br><br>
                                <br>
                                For example, Node.childNodes is live:<br>

                                const parent = document.getElementById('parent'); <br>
                                let child_nodes = parent.childNodes;<br><br>

                                <u>Static NodeLists</u> <br>
                                In other cases, the NodeList is static, where any changes in the DOM does not affect the content of the collection. <br>
                                The ubiquitous document.querySelectorAll() method returns a static NodeList. <br>
                                It's good to keep this distinction in mind when you choose how to iterate over the items in the NodeList, <br>
                                and whether you should cache the list's length.
                            </td>
                            <td>Live vs. Static NodeLists
                                <br><br>
                                document.getElementsByTagName / document.getElementsByClassName VS querySelector
                            </td>
                        </tr>
                        <tr>
                            <td>
                                console.log(logo.src); &emsp; // http://localhost/myProject/images/abc.jpg <br><br>
                                console.log(logo.getAttribute('src')); &emsp; // "images/abc.jpg"
                            </td>
                            <td>get relative version of image/link vs get full path </td>
                        </tr>
                        <tr>
                            <td>

                                <b><span>Window.scrollTo()</span></b><br>
                                Window.scrollTo() method scrolls to a particular set of coordinates in the document.<br>

                                notice how we need to selected the whole page (document.documentElement) to do the scroll to on.<br>
                                We need to specify left, top and behavior, and if we pass an object with options (required for smooth scroll) we should use polyfill as this is not ie10 or safari compatible <br>

                                window.scrollTo({ <br>
                                &emsp; left: s1coords.left + window.scrollX, <br>
                                &emsp; top: s1coords.top + window.scrollY,<br>
                                &emsp; behavior: 'smooth',<br>
                                });<br><br>

                                <b><span>Element.scrollIntoView()</span></b><br>
                                Element.scrollIntoView() method scrolls the element on which it's called into the Viewport of the browser window. <br>
                                This will jump to the area with specify, <br>
                                use pollyfill if we are passing the object settings into the method. (which is required for smooth scrolling). <br> <br>

                                section1.scrollIntoView({ behavior: 'smooth' }); <br>

                                other options <br>
                                // block: "start" / "center" / "nearest" <br>
                                // inline:"nearest" / "center" / "nearest" <br>
                            </td>
                            <td>Implementing smooth scrolling</td>
                        </tr>
                        <tr>
                            <td>
                                we need to use dataset for the data part and camelCase for the bit after, data-version-number="" <br>
                                console.log(logo.dataset.versionNumber);</td>
                            <td>How to get the value from the HTML "data-" attribute. </td>
                        </tr>
                    </tbody>
                </table>
            </td>
        </tr>

        <!-- Data Structures, Modern Operators and Strings -->
        <tr>
            <td>
                <table class="section">
                    <caption>
                        <h3 id="DS">Data Structures</h3>
                        <br>
                        <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="noopener noreferrer">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array</a>
                    </caption>
                    <thead>
                        <tr>
                            <td>Code</td>
                            <td>Description</td>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                <b> <span> slice</span> -> slices a chunk from an array, but does NOT mutate the original.</b> <br>
                                <u>slice example</u><br><br>
                                const animals = ['ant', 'bison', 'camel', 'duck', 'elephant'];<br>

                                console.log(animals.slice(2));<br>
                                // expected output: Array ["camel", "duck", "elephant"]<br><br>

                                console.log(animals.slice(2, 4));<br>
                                // expected output: Array ["camel", "duck"]<br><br>

                                console.log(animals.slice(-2));<br>
                                // expected output: Array ["duck", "elephant"]<br><br>

                                console.log(animals.slice(2, -1));<br>
                                // expected output: Array ["camel", "duck"]<br><br>

                                <b><span> splice</span> -> is mainly used for deleting elements from an array as it mutate the original array when we use it.</b>
                                <br><br>
                                <u>splice example</u><br>
                                const months = ['Jan', 'March', 'April', 'June'];<br>
                                months.splice(1, 0, 'Feb');<br>
                                // inserts at index 1<br>
                                console.log(months);<br>
                                // expected output: Array ["Jan", "Feb", "March", "April", "June"]<br><br>

                                months.splice(4, 1, 'May');<br>
                                // replaces 1 element at index 4<br>
                                console.log(months);<br>
                                // expected output: Array ["Jan", "Feb", "March", "April", "May"]<br>
                            </td>
                            <td>
                                Slice vs Splice (Arrays)
                            </td>
                        </tr>


                        <tr>
                            <td>
                                The concat() method is used to merge two or more arrays. <br> This method does not change the existing arrays, but instead returns a new array. <br><br>
                                const array1 = ['a', 'b', 'c']; <br>
                                const array2 = ['d', 'e', 'f']; <br>
                                const array3 = array1.concat(array2); <br> <br>

                                console.log(array3); <br>
                                // expected output: Array ["a", "b", "c", "d", "e", "f"]

                            </td>
                            <td>
                                array.concat() (Arrays)
                            </td>
                        </tr>
                        <tr>
                            <td>
                                map, filter, reduce, find -> array methods that work like the forEach method. <br>
                                <ul>
                                    <li>map - returns a new array containing the results of applying an operation on all original array elements. <br>
                                        if we want a new array the same length as the original we use map</li>
                                    <li>filter - returns a new array containing the array elements that passed a specified test condition.</li>
                                    <li>reduce - boils ("reduces") all array elements down to one single value (eg. adding all elements together) uses acc + current
                                    </li>
                                    <li>find</li>
                                </ul>
                                <span><b><u>map</u></b> </span><br>
                                forEach mutates the original array whilst .map creates a new one. <br><br>

                                <b>Pass a function to Array.map</b><br>
                                _generateMarkUp() {<br>
                                return this._data.map(this._generateMarkUpPreview).join('');<br>
                                }<br><br>

                                <span>Use Functions to generate HTML markup when possible!</span><br>
                                _generateMarkUpPreview() {<br>
                                return `<br>
                                &emsp; &lt;li class="preview"><br>
                                &emsp; &emsp; &lt; a class="preview__link" href="#23456"><br>
                                &emsp; &emsp;&emsp; &lt;figure class="preview__fig"><br>
                                &emsp; &emsp;&emsp;&emsp; &lt; img src="src/img/test-1.jpg" alt="Test" /><br>
                                &emsp; &emsp;&emsp; &lt;/figure><br>
                                &emsp; &emsp; &lt;/a><br>
                                &emsp; &lt;/li>`;<br>
                                }

                                <br><br>

                                <span><b><u>reduce</u></b> </span><br>
                                The initial value is the value of the total parameter when the reduction starts. <br>
                                You set the initial value by adding a comma followed by your initial value inside the parentheses but after the curly braces. <br><br>

                                const average = euros.reduce((total, amount, index, array) => {<br>
                                &emsp; total += amount<br>
                                &emsp; return total/array.length<br>
                                }, 0);<br><br>
                                <br> By omitting the initial value ",0 )", the total will default to the first amount in the array. <br><br>

                                <b><u>(advanced reduce methodology w destructuring)</u></b><br>
                                const { deposits, withdrawals } = accounts<br>
                                .flatMap(account => account.movements)<br>
                                .reduce(<br>
                                (accu, cur) => {<br>
                                // cur > 0 ? (accu.deposits += cur) : (accu.withdrawals += cur);<br>
                                // return accu;<br>

                                accu[cur > 0 ? 'deposits' : 'withdrawals'] += cur; // dynamic conditional object call<br>
                                return accu;<br>
                                },<br>
                                { deposits: 0, withdrawals: 0 }<br>
                                );<br><br>

                                console.log(deposits, withdrawals);<br><br>

                                <span><b><u>.find / .filter</u></b> </span><br>
                                array.filter and array.find are pretty similar but the key difference is that
                                <ul>
                                    <li>.filter returns all elements that meet the specified condition and returns a new array </li>
                                    <li> .find method only returns the first one and returns the element itself (not a new array).</li>
                                </ul>
                                <br>
                                <b>We can use the .find method to find a object in an array of objects when the object meets a certain condition.</b><br>

                                const accountJess = accounts.find(acc => acc.owner === 'Jessica Davis'); <br>
                                console.log(accountJess);

                                <br>
                                do NOT chain methods that mutate the original array. eg splice, reverse. <br>
                                Also try to minimize the amount of chaining at any possible opportunity especially on big arrays.
                                <br>

                            </td>
                            <td>
                                Data Transformations: map, filter, reduce (Arrays) <br>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <span>Array.flat()</span><br>
                                Using Flat() method in Javascript<br>
                                It concatenates all the elements of the given multidimensional array, and flats upto the specified depth. <br>
                                By default, the depth limit is 1. It can be 1 to Infinity. <br>

                                array.flat() only goes one layer deep when flattening the array. <br>

                                array.flat(2 will go 2 layers deep. <br>
                                <br>
                                <span>flatMap()</span> <br>
                                flatMap() truly does only go 1 layer deep and if we do need to go any deeper then we will need to use the flat method. <br>
                                Flat map first runs the map function then flatten the array after. <br><br>

                                //// Flat map (maps first and then flattens after) <br>
                                let arr1 = [1, 2, 3, 4]; <br> <br>

                                arr1.map(x => [x * 2]); <br>
                                // [[2], [4], [6], [8]] <br> <br>

                                arr1.flatMap(x => [x * 2]); <br>
                                // [2, 4, 6, 8] <br> <br>

                                // only one level is flattened <br>
                                arr1.flatMap(x => [[x * 2]]); <br>
                                // [[2], [4], [6], [8]] <br> <br>


                                Array.from also takes a .map as the second argument. <br> <br>

                                labelBalance.addEventListener('click', function () { <br>
                                &emsp; const movementsUI = Array.from( <br>
                                &emsp; &emsp; document.querySelectorAll('.movements__value'), <br>
                                &emsp; el => el.textContent.replace('£', '') <br>
                                ); <br>

                                console.log(movementsUI);
                                });

                                <br> <br>
                                Another way we could have done this is with the spread operator but then we would have had to use the map method separately.
                                <br>
                                const movementsUI = [...document.querySelectorAll('.movements__value')]


                            </td>
                            <td>flat / flatMap / Array.from (Arrays)</td>
                        </tr>
                        <tr>
                            <td>
                                <ul>
                                    <li>array.findIndex returns the index</li>
                                    <li>array.find will return just the element itself.</li>
                                </ul>
                                <b>
                                    They are quite similar to the <span>array.indexOf and array.index methods</span> but the only difference being <br>
                                    that we enter complex conditions for the call back function to search for and It will return the <br>
                                    element that meets the specified condition that we set. <br><br>
                                </b>
                                const index = accounts.findIndex(function (acc) { <br>
                                &emsp; return acc.username === currentAccount.username; <br>
                                });<br>

                                console.log(accounts[index]); <br><br>

                                const receiverAccount = accounts.find(<br>
                                &emsp; acc => acc.username === inputTransferTo.value<br>
                                );<br>
                            </td>
                            <td>array.findIndex & array.find Methods</td>
                        </tr>
                        <tr>
                            <td>
                                /// <span>INCLUDES</span> (returns boolean) <br>
                                console.log(test.includes(450));<br><br>

                                // <span>SOME</span> true if any/some elements in the array meet our CONDITION<br>
                                console.log(test.some(el => el === 70));<br><br>

                                // <span>EVERY</span> true if all elements in the array meet our CONDITION<br>
                                console.log(test.every(el => el > 0));<br><br>

                                // <span>EVERY</span> with a separate callback<br>
                                const deposit = mov => mov > 0;<br>
                                console.log(test.every(deposit));<br>

                                More array methods and also passing a separate callback function rather than writing it inside the method. <br>
                                (Good for the DRY principle) if we keep writing the same code.

                            </td>
                            <td>
                                .includes / .some / .every (Arrays)
                            </td>
                        </tr>
                        <tr>
                            <td> <b>array.Sort method</b> <br>

                                <ul>
                                    <li>The default sort order is ascending, built upon converting the elements into strings, then comparing their sequences of UTF-16 code units values.</li>
                                    <li>Converts everything to strings then sorts after.</li>
                                    <li>mutates the original array. and is good for sorting an array of numbers. Takes a callback function.</li>
                                </ul>

                                movements.sort((a, b) => a - b); <br>

                                //return < 0, A, B (keep order) <br>
                                    //return > 0, B, B (switch order)<br><br>

                                    //// 2 ways to sort ascending movements.sort((a, b) => { <br>
                                    &emsp; if (a > b) return 1;<br>
                                    &emsp; if (a < b) return -1; <br>
                                        }); <br><br>

                                        movements.sort((a, b) => a - b); // a will always return 1 same as above but optimized and works for number. <br>

                            </td>
                            <td>array.Sort</td>
                        </tr>
                        <tr>
                            <td>
                                arr.at is a new es2022 method that makes it easier to get the last element of an array <br><br>

                                arr[arr.length - 1]; // old way <br>
                                arr.slice(-1)[0]; // 2nd old way <br>
                                arr.at(-1); // new way! <br> <br>

                                The new at method also works on strings!
                            </td>
                            <td>
                                The new at Method(Arrays)
                            </td>
                        </tr>
                        <tr>
                            <td>

                                const x = new Array(7); // creates a blank array with 7 elements. <br>

                                x.fill(1, 3, 5); // adds 1,s in position 3 and 4 <br>
                                console.log(x); <br>

                                <ul>
                                    <li>We can the call the new .fill method to fill it all with this one element.</li>
                                    <li>(.fill is similar to slice) as we can also specify where the fill starts from and where it ends.</li>
                                    <li></li>
                                </ul>

                                Array.from gives us the same result as when we use the new Array(7) <br><br>
                                In this one-liner, the first argument of the from method is the object we want to create an array from. <br>
                                In this case, we are creating an empty object with a length property set to 10. <br>
                                The second argument is a function that fills the array with whatever the result of our function is.<br>

                                const x = Array.from({ length: 7 }, () => 1); <br>
                                console.log(y)<br> <br>

                                const y = Array.from({ length: 7 }, (cur, i) => i + 1); <br>
                                console.log(y)<br>
                                <br><br>

                                const z = Array.from({ length: 7 }, (_, i) => i + 1);<br>
                                console.log(z)<br><br>
                                use the underscore to show other programmers the current is not needed.
                            </td>
                            <td>
                                More Ways of Creating and Filling Arrays <br>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                Keep this technique of creating an array of exceptions in mind. <br><br>

                                // this is a nice title -> This Is a Nice Title <br><br>

                                const convertTitleCase = function (title) { <br>
                                &emsp; const capitilize = str => str[0].toUpperCase() + str.slice(1); // check out the missing ( brackets )<br>
                                &emsp; const exceptions = ['a', 'an', 'and', 'the', 'but', 'or', 'on', 'in', 'with']; <br><br>

                                &emsp; const titleCase = title <br>
                                &emsp; .toLowerCase() <br>
                                &emsp; .split(' ') <br>
                                &emsp; .map(word => (exceptions.includes(word) ? word : capitilize(word))) <br>
                                &emsp; .join(' '); <br><br>
                                return capitilize(titleCase); <br>
                                };
                                <br><br>
                                console.log(convertTitleCase('this is a nice title'));

                            </td>
                            <td>
                                Keep the technique of creating an array of exceptions in mind. <br>
                                Here we use it to create a function that converts all items in the Array to 'Proper case' if they are not included in the exception array.
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <b>Objects that can be used in for..of are called iterable.</b><br>

                                <ul>
                                    <li>Technically, iterables must implement the method named Symbol.iterator.
                                        <ul>
                                            <li>The result of obj[Symbol.iterator]() is called an iterator. It handles further iteration process.</li>
                                            <li>An iterator must have the method named next() that returns an object {done: Boolean, value: any}, here done:true denotes the end of the iteration process, otherwise the value is the next value.
                                            </li>
                                        </ul>
                                    </li>
                                    <li> The Symbol.iterator method is called automatically by for..of, but we also can do it directly.</li>
                                    <li> Built-in iterables like strings or arrays, also implement Symbol.iterator.</li>
                                    <li>String iterator knows about surrogate pairs.</li>
                                </ul>

                                <p>
                                    Objects that have indexed properties and length are called array-like. Such objects may also have other properties and methods, but lack the built-in methods of arrays.

                                </p>
                                <p>
                                    If we look inside the specification - we’ll see that most built-in methods assume that they work with iterables or array-likes instead of “real” arrays, because that’s more abstract.
                                </p>
                                <p>
                                    Array.from(obj[, mapFn, thisArg]) makes a real Array from an iterable or array-like obj, and we can then use array methods on it. The optional arguments mapFn and thisArg allow us to apply a function to each item.
                                </p>
                                <br><br>

                                <u><b>EXAMPLE</b></u> <br>
                                <u>Create an array with random value (min, max) length</u> <br><br>

                                let randint = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min; <br>

                                <br>
                                create_random = { <br>
                                &emsp; min: -1, <br>
                                &emsp; max: 90, <br>
                                &emsp; length: 100, <br>
                                }; <br> <br>

                                create_random[Symbol.iterator] = function() { <br>
                                &emsp; return { <br>
                                &emsp; &emsp; start: 0, <br>
                                &emsp; &emsp; min: this.min, <br>
                                &emsp; &emsp; max: this.max, <br>
                                &emsp; &emsp; length: this.length, <br> <br>

                                &emsp; &emsp; next(){ <br>
                                &emsp; &emsp; &emsp; this.start++; <br>
                                &emsp; &emsp; &emsp; <span>return this.start < this.length ? {done:false, value:randint(this.min, this.max)} : {done:true}; </span> <br>
                                        &emsp; &emsp; } <br>
                                        &emsp; }; <br>
                                        }; <br>
                                        <br>
                                        <span>let array=Array.from(create_random); console.log(array);</span>

                            </td>
                            <td>Iterables: What is iterable?
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <span>while</span> loop should be used when we do not know the amount of times we need to loop, <br><br>

                                <span>for</span> loop we use when we know how many times we need to loop. <br><br>

                                <span>forEach</span> is the new version of the <span>for (const var of v) loop</span> <br>
                                <small> But the big difference is that you can NOT break out of a forEach loop! or continue.</small><br> <br>

                                for (const m of movements) { <br>
                                &emsp; if (m > 0) { <br>
                                &emsp; &emsp; console.log(`You deposited ${m}`); <br>
                                &emsp; } <br>
                                &emsp;else { <br>
                                &emsp; &emsp; console.log(`You withdrew ${Math.abs(m)}`); <br>
                                &emsp;} <br>
                                }
                                <br> <br>
                                movements.forEach(function (m) { <br>
                                &emsp; if (m > 0) { <br>
                                &emsp;&emsp; console.log(`You deposited ${m}`) <br>
                                &emsp; } else { <br>
                                &emsp;&emsp; console.log(`You withdrew ${Math.abs(m)}`) <br>
                                &emsp; } <br>
                                }); <br><br>

                                <span> how to get index with the for of loop</span> <br>
                                for (const [i, m] of movements.entries()) { <br>
                                &emsp; if (m > 0) { <br>
                                &emsp; &emsp; console.log(`m ${i}: You deposited ${m}`); <br>
                                &emsp; } else { <br>
                                &emsp; &emsp; console.log(`m ${i}: You withdrew ${Math.abs(m)}`); <br>
                                &emsp; } <br>
                                }
                                <br><br>
                                <span> how to get index with the forEach loop</span> <br>
                                movements.forEach(function (m, i) { <br>
                                &emsp; if (m > 0) { <br>
                                &emsp; &emsp; console.log(`m ${i}: You deposited ${m}`);<br>
                                &emsp; } else { <br>
                                &emsp; &emsp; console.log(`m ${i}: You withdrew ${Math.abs(m)}`) <br>
                                &emsp; } <br>
                                });

                                <br><br><br>
                                <span><b><u>The difference between for...of and for...in</span></u></b> <br>
                                <b> Both for...in and for...of statements iterate over something. The main difference between them is in what they iterate over. </b><br>

                                <ul>
                                    <li>The for...in statement iterates over the enumerable properties of an object. (keys)</li>
                                    <li>The for...of statement iterates over values that the iterable object defines to be iterated over. (values)</li>
                                </ul>
                                <u>The following example shows the difference between a for...of loop and a for...in loop when used with an Array.</u>

                                <br><br>
                                Object.prototype.objCustom = function() {};<br>
                                Array.prototype.arrCustom = function() {};<br><br>

                                const iterable = [3, 5, 7];<br>
                                iterable.foo = 'hello';<br>

                                for (const i in iterable) {<br>
                                &emsp; console.log(i); // logs "0", "1", "2", "foo", "arrCustom", "objCustom"<br>
                                }<br><br>

                                for (const i in iterable) {<br>
                                &emsp; if (iterable.hasOwnProperty(i)) {<br>
                                &emsp; &emsp; console.log(i); // logs "0", "1", "2", "foo"<br>
                                &emsp; }<br>
                                }<br><br>

                                for (const i of iterable) {<br>
                                &emsp; console.log(i); // logs 3, 5, 7<br>
                                }<br>
                                <br><br><br>
                                <b>Iterating over a DOM collection</b> <br>
                                Iterating over DOM collections like NodeList: <br>

                                // Note: This will only work in platforms that have implemented NodeList.prototype[Symbol.iterator] <br><br>
                                const articleParagraphs = document.querySelectorAll('article > p');<br><br>

                                for (const paragraph of articleParagraphs) {<br>
                                &emsp; paragraph.classList.add('read');<br>
                                }<br>
                            </td>
                            <td>which loop to use</td>
                        </tr>
                        <tr>
                            <td>
                                <b><u> Destructuring Assignment </u> </b><br>
                                let a,b; <br>
                                [a,b] = [100,200]; <br><br>

                                <b><u> Rest Pattern </u> </b> <br>
                                [a,b,c, ...test] = [100,200,300,400,500];<br><br> <br>

                                <b><u> Rest Pattern </u> </b> <br>
                                [a,b,c, ...test] = [100,200,300,400,500];<br><br><br>

                                <span> using the rest pattern on objects</span> <br>
                                ({a , b} = { a: 100, b: 200, c:300, d:400, e:500 }); <br>

                                ({a , b, ...rest} = { a: 100, b: 200, c:300, d:400, e:500 }); <br> <br><br>

                                <b><u> Array Destructuring </u> </b> <br>
                                const people = ['Billy', 'Jo', 'Shane']; <br>
                                const [person1, person2, person3] = people; <br>
                                console.log(person1, person2, person3); <br> <br><br>

                                <b><u> Parse array returned from function </u> </b> <br>
                                function getPeople(){ <br>
                                &emsp; return ['Jon', 'Sam', 'Ted']; <br>
                                } <br> <br><br>

                                let name1, name2, name3; <br> <br>

                                [name1, name2, name3 ] = getPeople(); <br> <br>

                                console.log(name1, name2, name3); <br> <br>

                                <b><u> Object Destructuring </u> </b> <br>
                                const person = { <br>
                                &emsp; name:'Jon Doe', <br>
                                &emsp; age: 44,<br>
                                &emsp; city: 'London',<br>
                                &emsp; gender: 'Male',<br>
                                &emsp; sayHello: function(){<br>
                                &emsp; &emsp; return 'Hello';<br>
                                &emsp; }<br>
                                }<br>

                                <br> <span> old ES5 </span><br>
                                const testName = person.name,<br>
                                testAge = person.age,<br>
                                testHello = person.sayHello();<br> <br>

                                console.log(testName,testAge);<br>

                                <br> <span> New ES6 Destructuring </span><br>
                                const {name, age, city, sayHello} = person;<br>
                                <br>
                                console.log(name, age, city, sayHello());<br><br><br>

                                <br> <span> Destructuring nested objects </span><br>

                                const openingHours = { <br>
                                &emsp; sat: { <br>
                                &emsp;&emsp; open: 0, <br>
                                &emsp;&emsp; close: 24, <br>
                                &emsp; },<br>
                                };<br><br>

                                const {<br>
                                &emsp; sat: {open, close}<br>
                                } = openingHours;<br>
                                <br>
                                console.log(open, close);
                                <br>
                                This is the syntax we would use /// only works with the same name

                                <br><br>

                                <br> <span> Destructuring the parameters in an object method call</span><br>

                                const restaurant = {<br>
                                &emsp; orderDelivery: function ({ starterIndex, mainIndex, time, address }) {<br>
                                &emsp; &emsp; console.log(Order received! ${this.starterMenu[starterIndex]} and ${this.mainMenu[mainIndex]} will be delivered to ${address} at ${time}.`);<br>
                                &emsp; }<br>
                                };

                                <br><br>
                                <b>The names MUST be the same but notice how it doesn't matter which order the parameter are call, JavaScript works it out for us and puts them in the correct order.</b>
                                <br><br> <u>Call them like this</u><br>
                                restaurant.orderDelivery({ <br>
                                &emsp; time: '22:30',<br>
                                &emsp; address: 'Villa da sol',<br>
                                &emsp; mainIndex: 2,<br>
                                &emsp; starterIndex: 2,<br>
                                });

                                <br><br><br>
                                To mutate an object you will need to wrap it in () like this <br>
                                ({ a ,b } = obj);<br>

                                <u><b>nested array destructuring</b></u> <br>

                                const nested = [2, 4, [5, 6] ]; <br>
                                const [,i , [,j]] = nested; <br><br>

                                <u><b>nested Object destructuring</b></u><br>

                                only works when the name of the variable is exactly the same as the property names that we want to retrieve from the object. (Handy when getting data from API) <br>

                                let recipe = data.data.recipe; // old way <br>
                                let {recipe} = data.data; // new way with destructuring <br>

                                <b>We do not need to specify empty spaces or order like we with arrays (by using the comma,) as the order does not matter with object destructuring.</b><br>

                                <br><br>
                                <u><b>How to destructure an object (but give the variables new names)</b></u><br>
                                const {name : theNewName, openingHours: theNewOpeningHours, categories: typesOfFood} = restaurant; <br> <br>

                                <u>the same but with adding default values just incase anything returns undefined.</u><br>

                                const {
                                menu = [], openingHours
                                } = restaurant;

                            </td>
                            <td>Destructuring</td>
                        </tr>
                        <tr>
                            <td>
                                The spread ... operator is similar to destructuring, as it also helps get elements out of arrays (literally). <br>
                                The spread operator is used where we would other wise use values separated by a comma. <br>
                                <br>
                                The rest operator does the opposite of the spread operator. <br> The rest packs things up to a new array whilst the spread spreads them out. <br>
                                The rest operator is used where we would otherwise use variable names separated by commas
                                <br> <br>
                                <u><b>This is how we know what's being used and when to use spread or rest.</b></u>
                                <br>
                                <span> SPREAD, because on RIGHT side of = </span> <br>
                                const arr = [1, 2, ...[3, 4]];<br><br>

                                <span>REST because on LEFT side of = </span><br>
                                const [a, b, ...other] = [1, 2, 3, 4, 5];<br> <br>
                                <b>The rest item must be the last element in the array else it will throw an error.</b> <br> <br>
                                Use ...spread when we don't know how many parameters are being put into a function from an array.

                            </td>
                            <td>The difference between the rest and the spread operator</td>
                        </tr>
                        <tr>
                            <td>
                                <span>Create a Set</span><br>
                                const set1 = new Set();<br> <br>

                                <span> Add values to Set<br> </span>
                                set1.add(100);<br>
                                set1.add('A string');<br>
                                set1.add({name: 'Jon'});<br>
                                set1.add(true);<br>
                                <br>
                                set1.add(100); // this will not be added as there is already one in the set, each set value must be unique<br>
                                <br>
                                <br> <br> <span> a different way to add values to Set </span><br>
                                const set2 = new Set([1, true, 'String']);<br> <br>

                                console.log(set2);<br>

                                <br>
                                <br> <span>Get count </span><br>
                                set1.size;<br>

                                <br> <span> check for values </span><br>
                                set1.has(100); // true<br>
                                set1.has(50 + 50); // true<br>
                                <br>
                                <br> <span> Delete from set </span><br>
                                set1.delete(100);<br>

                                <br> <b> <u> ITERATING THROUGH SETS</u></b><br>

                                <span>for of loop </span> <br>
                                for (const item of set1) {
                                <br> &emsp; console.log(item); <br>
                                }<br>
                                <br>
                                <span> forEach </span> <br>
                                set1.forEach((key) => {<br>
                                &emsp; console.log(key);<br>
                                });<br>
                                <br>
                                <br>
                                <span>Convert SET TO ARRAY </span><br>
                                const setArr = Array.from(set1);<br><br> <br>
                                <ul>
                                    <li> Sets are like arrays, but there items must be unique and any non unique items will be removed from the array. There order is also irrelevant unlike the array.</li>
                                    <li>Store unique values of any type, sets are not key value pairs they are just single value </li>
                                    <li>we can never retrieve items out of a set! we should use an array if we want to do this, although sets are iterable.</li>
                                    <li>Sets are just for storing data. We can only check if an item exists inside of the set with the .has method</li>
                                    <li>We use .size rather than .length to find out how many items we have inside of the set. </li>
                                    <li>it also uses a .has method which is similar to the .includes method that we use on arrays. </li>
                                    <li>A set can be any iterable item, so we can also use them with strings.</li>
                                    <li>The main use case for sets would be to remove duplicate items from an array. </li>
                                </ul>
                            </td>

                            <td> <u><b>SETS</b></u> <br> <br><br>

                            </td>
                        </tr>
                        <tr>
                            <td>
                                <span> Create Map </span> <br>
                                const map1 = new Map(); <br>
                                <br>
                                <span> Set keys </span> <br>
                                const key1 = 'some string', <br>
                                key2 = {}, <br>
                                key3 = function(){}; <br>

                                <br>
                                <span> Set map values by key </span> <br>
                                map1.set(key1, 'Value of key1'); // 'some string' is now the key <br>
                                map1.set(key2, 'Value of key2'); // {} empty object, is now the key <br>
                                map1.set(key3, 'Value of key3'); // empty function is now the key <br>
                                <br>
                                <span> Get Values by key </span> <br>
                                console.log(map1.get(key1), map1.get(key2), map1.get(key3)); <br>
                                <br>
                                <br> <span>Count Values </span>
                                console.log(map1.size); // returns 3 <br>
                                <br>
                                <br> <b><u> ITERATING MAPS</u> </b> <br>

                                <span> Loop using for...of to get keys and values </span><br>
                                for(let [key, value] of map1){ <br>
                                <br> &emsp; console.log(`${key} = ${value}`); <br>
                                } <br>
                                <br>
                                <br> <span> Iterate keys only </span> <br>
                                for(let key of map1.keys()){ <br>
                                <br> &emsp; console.log(key);
                                <br> }

                                <br> <span> Iterate value only </span>
                                <br> for(let value of map1.values()){
                                <br> &emsp; console.log(value);
                                <br> }
                                <br>

                                <br> <span> Loop with a forEach </span> <br>
                                <br> map1.forEach((value,key) =>{ <br>
                                <br> &emsp; console.log(`${key} = ${value} `); <br>
                                <br> });
                                <br>

                                <span> CONVERT an array of the key value pairs </span> <br>
                                const keyValArr = Array.from(map1); <br>
                                console.log(keyValArr); <br>

                                <br> <span> CONVERT an array of the keys </span> <br>
                                const keyArr = Array.from(map1.keys()); <br>
                                console.log(keyArr); <br>
                                <br>
                                const valueArr = Array.from(map1.values()); <br>
                                console.log(valueArr); <br> </td>
                            <td><b> <u> MAPS </u></b> <br> key:value pairs, we can use ANY type as a key or a value.</td>
                        </tr>
                        <tr>
                            <td>
                                <span> Create symbol </span> <br>
                                const sym1 = Symbol();<br>
                                const sym2 = Symbol('sym2');<br>

                                // console.log(typeof(sym2));<br>

                                <span> Returns false as no two symbols can be the same </span><br>
                                // console.log(Symbol('123') === Symbol('123'));<br>

                                <br>
                                <span> Unique Object Keys </span><br>
                                const KEY1 = Symbol();<br>
                                const KEY2 = Symbol('sym2');<br>
                                <br>
                                const myObj = {};<br>
                                <br>
                                <span> this will not work as a symbol must use square brackets </span><br>
                                // myObj.KEY1 = 'Prop1';<br>
                                <br>
                                // you will have to use square brackets like this<br>
                                myObj[KEY1] = 'Prop1';<br>
                                myObj[KEY2] = 'Prop2';<br>
                                myObj.key3 = 'Prop3';<br>
                                myObj.key4 = 'Prop4';<br>
                                <br>
                                <br> // console.log(myObj[KEY1]);<br>
                                <br> // console.log(myObj[KEY2]);<br>
                                <br>
                                <br> // symbols are not enumerable in for....in (they wont show up in the loop!)
                                <br> // for(let i in myObj){
                                <br> // &emsp; console.log(`${i}: ${myObj[i]}`);
                                <br> // }
                                <br>
                                <br>
                                <br> // Symbols are ignored by JSON.stringify<br>
                                console.log(JSON.stringify({key: 'prop'}));<br>
                                console.log(JSON.stringify({[Symbol('test')]: 'prop'})); // just shows as an empty object.<br> </td>
                            <td>Symbol() - Symbols<br> For Unique Object Keys</td>
                        </tr>
                        <tr>
                            <td>
                                Use arrays most of the time over sets but use a set if you need to remove duplicates from arrays or if you need to work with unique values <br><br>
                                Use objects when you need to include functions, (this can not be done with maps) or when working with JSON.
                                <br><br>
                                Use maps when you want to use keys that are NOT strings or when you simply need to map key to values. </td>
                            <td>When to use arrays vs sets && maps vs objects</td>
                        </tr>
                    </tbody>
                </table>
            </td>
        </tr>

        <!-- Numbers, Dates, Intl and Timers -->
        <tr>
            <td>
                <table class="section">
                    <caption>
                        <h3 id="numbers">Numbers, Dates, Intl and Timers</h3>
                    </caption>
                    <thead>
                        <tr>
                            <td>Code</td>
                            <td>Description</td>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>const now = new Date(); <br>

                                <ol>
                                    <li>The Date object has lots a built in functions.</li>
                                    <li>Always use getFullYear(); Do not ever use getYear()</li>
                                    <li>but for other getters we do not inlude 'full eg. 'getMonth()</li>
                                    <li>Dates also have setters, setMonth() etc.</li>
                                    <li>We can get the timestamp / number of miliseconds passed since 1970 by using Date.now();</li>
                                </ol>

                                <b><span><u>Display formatted Date example/u></span></b>
                                const date = new Date(acc.movementsDates[i]); <br>

                                // const now = new Date();<br>
                                const day = `${date.getDate()}`.padStart(2, 0); // adds 0 to 1 digit months<br>
                                const month = `${date.getMonth() + 1}`.padStart(2, 0);<br>
                                const year = date.getFullYear();<br>
                                const hours = date.getHours();<br>
                                const minutes = date.getMinutes();<br><br>

                                const displayDate = `${day}/${month}/${year}`;<br> <br><br>

                                <a href="https://momentjs.com/" target="_blank" rel="noopener noreferrer">moment.js</a> is a popular free JavaScript library for calculating complex date equations <br><br>

                                <b><span>Calculate days passed</span></b> <br>
                                const formatMovementDate = function (date) {<br>
                                const calcDaysPassed = (date1, date2) => Math.round(Math.abs(date2 - date1) / (1000 * 60 * 60 * 24));<br><br>

                                const daysPassed = calcDaysPassed(new Date(), date);<br>

                                console.log(daysPassed);<br><br>

                                if (daysPassed === 0) return 'Today';<br>
                                if (daysPassed === 1) return 'Yesterday';<br>
                                if (daysPassed <= 7) return `${daysPassed} days ago`;<br>
                                    else {<br>
                                    &emsp; &emsp; const day = `${date.getDate()}`.padStart(2, 0); // adds 0 to 1 digit months<br>
                                    &emsp; &emsp; const month = `${date.getMonth() + 1}`.padStart(2, 0);<br>
                                    &emsp; &emsp; const year = date.getFullYear();<br><br>

                                    &emsp; &emsp; return `${day}/${month}/${year}`;<br>
                                    &emsp; }<br>
                                    };<br> <br><br>

                                    <b><u><span>Int API (internationalization)</span></u></b> <br><br>

                                    labelDate.textContent = new Intl.DateTimeFormat('en-US').format(now);<br>

                                    returns the format in any language that we set it to<br><br>

                                    const now = new Date();<br><br>

                                    const options = {<br>
                                    &emsp; day: 'long',<br>
                                    &emsp; month: 'short',<br>
                                    &emsp; year: 'numeric',<br>
                                    &emsp; hour: 'numeric',<br>
                                    &emsp; minute: 'numeric',<br>
                                    };<br><br>

                                    const locale = navigator.language;<br>

                                    labelDate.textContent = new Intl.DateTimeFormat('en-US', options).format(now);<br><br>

                                    // or to set to local<br>
                                    labelDate.textContent = new Intl.DateTimeFormat(locale, options).format(now);<br><br>

                                    <b>We can do the same with numbers</b> <br><br>

                                    const number = 3445349.34;<br>

                                    const options = {<br>
                                    &emsp; style: 'percent',<br>
                                    &emsp; unit: 'mph',<br>
                                    };<br><br>

                                    console.log(new Intl.NumberFormat('en-US', options));

                            </td>
                            <td>Creating Dates <br><br>
                                <a rel="noopener noreferrer" target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date">MDN</a> </td>
                        </tr>
                        <tr>
                            <td>
                                <b><span>Always use isFinite</span> rather than isNAN to check if something is or is not a number, this is because isNaN produces some strange results</b> <br><br>

                                console.log(Number.isNaN(20)); // false<br>
                                console.log(Number.isNaN('20')); // false<br>
                                console.log(Number.isNaN(+'20X')); // true<br>
                                console.log(Number.isNaN(23 / 0)); // false (infinity)<br>
                                console.log(Number.isFinite(20)); true<br>
                                console.log(Number.isFinite('20')); false<br>
                                console.log(Number.isFinite(+'20X')); false<br>
                                console.log(Number.isFinite(23 / 0)); false<br><br>


                                // for ints with no float<br><br>

                                console.log(Number.isInteger('44'));<br>
                                console.log(Number.isInteger(44));<br><br>



                                <ul>
                                    <li> You can NOT do really precise scientific or financial calculation in JavaScript due to it using binary base 2. eg. 0.1 + 0.2 = 0.30000000000004</li>
                                    <li> All numbers convert to floats, using the + sign on a string will convert it to a number</li>
                                </ul>
                                <br>
                                make something run every nth time <br>

                                <br> if(i % 3 === 0) {<br>
                                } <br><br>
                                Math.trunc rounds down a number to an integer towards 0 <br>
                                while Math.floor rounds down a number to an integer towards -Infinity. <br>
                                As illustrated with the following number line, the direction will be the same for a positive number while for a negative number, the directions will be the opposite.
                                <br>
                                <img src="./resources/trunc-vs-floor.jpg" height="200" width="660">
                                <br><br>
                                <b>When rounding decimals</b> .toFixed will always return a string not a decimal, <br>
                                use the + sign if we want to convert it back to a number <br>
                                console.log(+(2.5).toFixed(0));

                                <br><br>
                                Number provides a name space for parseFloat and parseInt. <br>
                                Although they are global functions it is recommended that we call the on the Number object.<br><br>

                                console.log(Number.parseInt('30px', 10)); // <span> always use the 10 for base 10 standard numbers to avoid bugs.</span><br>
                                console.log(Number.parseInt('010100001px', 2)); // </span> use 2 if we are working with binary.</span><br><br>

                                console.log(Number.parseFloat('2.5rem')); // 2.5<br>
                                console.log(Number.parseInt('2.5rem')); // 2<br><br>
                                <span>Number.ParseFloat</span> // should be the go to when getting values from CSS that include px, rem and wanting to strip it out. <br><br>

                            </td>
                            <td>Converting and Checking Numbers</td>
                        </tr>
                        <tr>
                            <td>
                                <ul>
                                    <li> Any number that is bigger than Number.MAX_SAFE_INTEGER; needs a big int else we will lose precision. These are unsafe numbers.</li>
                                    <li>BigInt is used by either adding a n onto the end of the number like this 3143104308929048243242n</li>
                                    <li>or by using the BigInt(90843043) constructor function.
                                    </li>
                                    <li>We can NOT add a bigInt to a normal number</li>
                                    <li>We can NOT use math functions on a BigInt</li>
                                    <li>BigInt was added in es2020</li>
                                </ul>
                            </td>
                            <td>Working with BigInt</td>
                        </tr>
                        <tr>
                            <td>
                                <b>Pass parameters</b><br>
                                setTimeout( (ing1, ing2) => console.log(`here is your pizza with ${ing1} and ${ing2}`),<br>
                                3000,<br>
                                'olives',<br>
                                'spinach'<br>
                                );<br><br>

                                <b>We can cancel as timer or interval before it has happened, but we will need to name it.</b>
                                <br>
                                const cancelMe = setTimeout((ing1, ing2) => console.log(`here is your pizza with ${ing1} and ${ing2}`),
                                3000,<br>
                                ...ingredients<br>
                                );<br><br>

                                if (ingredients.includes('bacon')) clearTimeout(cancelMe);<br> <br>


                                <span>We don't need to call the variable, it still runs automatically.</span> </td>
                            <td>Pass parameters to setTimeout and also how to cancel a timeout or interval</td>
                        </tr>
                    </tbody>
                </table>
            </td>
        </tr>

        <!-- Functions -->
        <tr>
            <td>
                <table class="section">
                    <caption>
                        <h3 id="functions">Functions</h3>
                    </caption>
                    <thead>
                        <tr>
                            <td>Code</td>
                            <td>Description</td>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td> The difference between an expression and a statement is that an expression produces a value. <br><br>

                                A statement does not produce a value, it just performs some value. They are like full sentences that describe what is going on. <br><br>

                                `template string literals` always expect an expression, so we can use a ternary operation, but we can not use an if statement. <br><br>

                                Operator and expression always produce a value. <br><br>

                            </td>
                            <td>Statements and Expressions</td>
                        </tr>

                        <tr>
                            <td>
                                <span>function declaration</span> <br>

                                function calcAge1(birthYear){ <br>
                                &emsp; return 2021 - birthYear; <br>
                                } <br>

                                const age1 = calcAge1(1989); <br><br>


                                <span>function expression</span> <br>
                                const calcAge2 = function (birthYear){ <br>
                                &emsp;&emsp;&emsp;&emsp;&emsp; &emsp;&emsp;&emsp;&emsp;&emsp; &emsp;&emsp;&emsp;&emsp;&emsp; return 2021 - birthYear; <br>
                                &emsp;&emsp;&emsp;&emsp;&emsp; &emsp;&emsp;&emsp;&emsp;&emsp; &emsp;&emsp;&emsp;&emsp;&emsp;} <br>

                                const age2 = calcAge2(1989); <br><br>

                                <span>The arrow function is also a function expression.</span> <br>

                                Const calcAge3 = birthYear => 2021 - birthYear; <br><br>


                                The main difference is that function declarations can be called before they are defined in the code. <br><br>

                                It comes down to personal preference on which style you choose to use.


                            </td>
                            <td>function declaration vs function expression</td>
                        </tr>
                        <tr>
                            <td>You can create a function to return an array when you want to return more than one thing. <br><br>

                                // ES6 method in an object. <br><br>
                                order(starterIndex, mainIndex) {<br>
                                &emsp; return [this.starterMenu[starterIndex], this.mainMenu[mainIndex]];<br>
                                },
                            </td>
                            <td>Make a function return more than one thing by returning an array</td>
                        </tr>
                        <tr>
                            <td>
                                <span>// Before, using ES5...<br></span>
                                function greetES5(message, to) { <br>
                                &emsp; // Test parameter values in the function body, specifying a default <br>
                                &emsp; to = to || 'DOM'; <br>
                                &emsp; // OR if (typeof to === undefined) { to = 'DOM'; } <br>
                                &emsp; // OR if (arguments.length === 1) { to = 'DOM'; } <br>
                                &emsp; ChromeSamples.log(message + ', ' + to); <br>
                                }<br>
                                greetES5('Good morning'); <br>
                                greetES5('Sup', 'CSS'); <br> <br>

                                <span>// After using ES2015/ES6...</span> <br>
                                // Define default parameter values in the function head <br>
                                function greet(message, to = 'DOM') { <br>
                                &emsp; ChromeSamples.log(message + ', ' + to); <br>
                                } <br>

                                greet('Good morning');<br>
                                greet('Sup', 'CSS'); <br> <br>
                                it's always best to pass data into a function rather that have it in the global scope <br> <br>

                                const displayMovements = function(movements){} <br> <br>

                                displayMovements(account1.movements) <br>

                            <td>Default parameters in functions ES5 & ES6 way</td>
                        </tr>
                        <tr>
                            <td>
                                <ul>
                                    <li>Arrow functions allow you to have an implicit return: values are returned without having to use the return keyword.</li>
                                    <li>It works when there is a on-line statement in the function body: </li>
                                    <li> In a arrow function the body is only automatically returns when we do NOT have the curly brackets.</li>
                                    <li> If we have included the curly brackets then we also need to include the return statement.</li>
                                    <li>Implicit return, but only if there is no block.</li>
                                    <li>This will result in errors when a one-liner expands to multiple lines and the programmer forgets to add a return.</li>
                                    <li> Implicit return is syntactically ambiguous. (name) => {id: name}returns the object {id: name}... right? Wrong. It returns undefined. Those braces are an explicit block. id: is a label.</li>
                                </ul>
                            </td>
                            <td>Arrow functions</td>
                        </tr>
                        <tr>
                            <td> <b><u> ITERATOR EXAMPLE </u> </b> <br><br>
                                function nameIterator (names){<br>
                                &emsp; let nextIndex = 0;<br>
                                <br>
                                &emsp; return {<br>
                                &emsp; &emsp; &emsp; &emsp; next: function(){
                                <br> &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; return nextIndex < names.length ? {value: names[nextIndex++], done:false } : {done: true};<br>
                                    &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; }<br>
                                    &emsp; }<br>
                                    }<br>
                                    <br>
                                    <span> Create an array of names </span><br>
                                    const namesArr = ['Jack', 'Jill', 'Jon'];<br>
                                    <br>
                                    <span>Init iterator and pass in the names array </span><br>
                                    const namesTest = nameIterator(namesArr);<br>
                                    <br>

                                    // returns Jack<br>
                                    console.log(namesTest.next().value);<br>
                                    <br> // returns Jill<br>
                                    console.log(namesTest.next().value);<br>
                                    <br> // returns Jon<br>
                                    console.log(namesTest.next().value);<br>
                                    <br> // returns Undefined, done:true<br>
                                    console.log(namesTest.next().value);<br>
                                    <br>
                                    <br>

                                    <span> <b>
                                            <u>Profile Iterator (good for carousel) </span></u>
                                    </b> <br>
                                    function profileIterator(profiles){ <br> <br>
                                    &emsp; let nextIndex = 0; <br> <br>

                                    &emsp; return{ <br>

                                    &emsp; &emsp; &emsp; &emsp; next:function(){ <br>
                                    &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; return nextIndex < profiles.length <br>
                                        &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; ? <br>
                                        &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; {value: profiles[nextIndex++], done: false } <br>
                                        &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp;: <br>
                                        &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; {value: profiles[(nextIndex++) % profiles.length], done: false} <br>
                                        <br> &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp;; <br>
                                        &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; } <br>
                                        <br>
                                        &emsp; } <br>

                                        } <br> <br>

                                        <u> Call it like This </u> <br>

                                        const profiles = profileIterator(data); // data was an array of objects <br>
                                        function nextProfile(){ <br>

                                        &emsp; // has to be done this way else each item will be one click ahead. eg "${profiles.next().value.image}"> <br>
                                        &emsp; const currentProfile = profiles.next().value; <br>
                                        } <br> <br>
                                        <br>
                                        <br> <b><u> GENERATOR EXAMPLE</u> </b> <br>
                                        <span> need to put the Star after the function here
                                            for this to work! <br>
                                            (Works the same as iterator but is just layed out in a different style)<br> </span>
                                        function* sayNames(){<br>
                                        &emsp; yield 'Sam';<br>
                                        &emsp; yield 'Bill';<br>
                                        &emsp; yield 'Fred';<br>
                                        } <br>
                                        <br>
                                        const testGenerator = sayNames();<br>
                                        <br>
                                        // returns Sam<br>
                                        console.log(testGenerator.next().value);<br>
                                        <br> // returns Bill<br>
                                        console.log(testGenerator.next().value);<br>
                                        <br> // returns Fred<br>
                                        console.log(testGenerator.next().value);<br>
                                        <br> // returns Undefined<br>
                                        console.log(testGenerator.next().value);<br> <br>

                                        <br> // ID Creator<br>
                                        function* CreateIds(){<br>
                                        &emsp; let index = 0;<br>
                                        &emsp; <br>
                                        &emsp; while(true){<br>
                                        &emsp; &emsp; yield index++; <br>
                                        &emsp; }<br>
                                        }<br> <br>

                                        // Will keep adding 1;<br>
                                        const gen = CreateIds(); <br>

                                        // 0<br> <br>
                                        console.log(gen.next().value);
                                        <br> // 1<br> <br>
                                        console.log(gen.next().value);
                                        <br> // 2<br> <br>
                            </td>
                            <td>Iterators and Generators</td>
                        </tr>
                        <tr>
                            <td>
                                They all attach this into function (or object) and the difference is in the function invocation <br>
                                <ul>
                                    <li>Call invokes the function and allows you to pass in arguments one by one.</li>
                                    <li>Apply invokes the function and allows you to pass in arguments as an array.</li>
                                    <li>Bind returns a new function, allowing you to pass in a this array and any number of arguments.</li>
                                </ul>

                                Use .bind() when you want that function to later be called with a certain context, useful in events. <br> <br>

                                Use .call() or .apply() when you want to invoke the function immediately, and modify the context. <br>
                                Call/apply call the function immediately, whereas bind returns a function that, when later executed, will have the correct context set for calling the original function. <br>
                                This way you can maintain context in async callbacks and events. <br><br><br>

                                <u><b>Apply vs. Call vs. Bind Examples</b></u> <br>

                                <span><b>Call</b></span><br><br>

                                var person1 = { firstName: 'Jon', lastName: 'Kuperman'};<br>
                                var person2 = {firstName: 'Kelly', lastName: 'King'};<br><br>

                                function say(greeting) {<br>
                                &emsp; console.log(greeting + ' ' + this.firstName + ' ' + this.lastName);<br>
                                }<br><br>

                                say.call(person1, 'Hello'); // Hello Jon Kuperman<br>
                                say.call(person2, 'Hello'); // Hello Kelly King<br><br><br>


                                <span><b>Apply</b></span><br><br>

                                var person1 = {firstName: 'Jon', lastName: 'Kuperman'};<br>
                                var person2 = {firstName: 'Kelly', lastName: 'King'};<br>

                                function say(greeting) {<br>
                                console.log(greeting + ' ' + this.firstName + ' ' + this.lastName);<br>
                                }<br><br>

                                say.apply(person1, ['Hello']); // Hello Jon Kuperman<br>
                                say.apply(person2, ['Hello']); // Hello Kelly King<br><br><br>

                                <span><b>Bind</b></span><br><br>
                                <u> Example 1 </u><br>
                                var person1 = {firstName: 'Jon', lastName: 'Kuperman'};<br>
                                var person2 = {firstName: 'Kelly', lastName: 'King'};<br>

                                function say() {<br>
                                &emsp; console.log('Hello ' + this.firstName + ' ' + this.lastName);<br>
                                }<br><br>

                                var sayHelloJon = say.bind(person1);<br>
                                var sayHelloKelly = say.bind(person2);<br><br>

                                sayHelloJon(); // Hello Jon Kuperman<br>
                                sayHelloKelly(); // Hello Kelly King<br><br><br>

                                <u>Example 2</u><br>
                                <br>
                                var multiby2 = multiplication.bind(this,2); <br>

                                Now multiby2(b) is equal to multiplication(2,b); <br>

                                multiby2(3); //6 <br>
                                multiby2(4); //8 <br> <br>

                                What if I pass both the parameters in bind? <br>

                                var getSixAlways = multiplication.bind(this,3,2); <br>
                                Now getSixAlways() is equal to multiplication(3,2); <br> <br>

                                getSixAlways();//6 <br>
                                even passing parameter returns 6; getSixAlways(12); //6 <br> <br>

                                var magicMultiplication = multiplication.bind(this); <br>
                                This create a new multiplication function and assigns it to magicMultiplication. <br>

                                Oh no, we are hiding the multiplication functionality into magicMultiplication. <br>

                                calling magicMultiplication returns a blank function b() <br>

                                on execution it works fine magicMultiplication(6,5); //30 <br> <br>

                                <span>How about call and apply?</span> <br>

                                magicMultiplication.call(this,3,2); //6 <br>

                                magicMultiplication.apply(this,[5,2]); //10 <br><br><br>

                                <span><b>When To Use Each?</b></span><br><br>

                                Call and apply are pretty interchangeable. Just decide whether it’s easier to send in an array or a comma separated list of arguments. <br>

                                Its good to remember which one is which by remembering that Call is for comma (separated list) and Apply is for Array. <br>

                                Bind is a bit different. It returns a new function. <br>
                                Call and Apply execute the current function immediately. <br>

                                Bind is great for a lot of things. We can use it to curry functions like in the above example. <br> We can take a simple hello function and turn it into a helloJon or helloKelly. <br>
                                We can also use it for events like onClick where we don’t know when they’ll be fired but we know what context we want them to have. <br> <br>
                                // we need to bind else this will point to the element that is clicked (this.options.join) <br>
                                document.querySelector('.btn').addEventListener('click', poll2.registerNewAnswer.bind(poll2));
                                <br>
                                <blockquote> Comparison between function objects, function calls, call/apply and bind</blockquote>
                                <img height="450" width="450" src="./resources/apply-call-bind.jpg">

                            </td>
                            <td> .call() & .apply() vs .bind() <br> <br>
                                <b>What do they do and which one should I use?</b></td>
                        </tr>
                        <tr>
                            <td>
                                Scope: the 4 types
                                <ol>
                                    <li>Global scope - > goes to the window (accessible everywhere).</li>
                                    <li>Function scope (accessible only inside the function Not Outside)</li>
                                    <li>Block scope. (only starts with es6 and only works with let and const variables, functions are also block scoped in strict mode).</li>
                                    <li>Lexical - looks to the outer function.</li>
                                </ol>
                                <ul>
                                    <li>One scope can only look up the scope chain, but can Never look down.</li>
                                    <li>scope has access to variable from all outer scopes. </li>
                                    <li>let and const are block scoped.</li>
                                    <li>var is scoped to the surrounding function</li>
                                </ul>
                            </td>
                            <td>Scope and The Scope Chain</td>
                        </tr>
                        <tr>
                            <td>
                                <ul>
                                    <li>The "this" keyword/variable. Points to the owner of the function. </li>
                                    <li>This is NOT static. It depends on how the function is called and its value is only assigned when the function is actually called.</li>
                                    <li>Methods - this = object that is calling the method.</li>
                                    <li>Function - this = undefined. (Only in strict mode, Otherwise this = window)</li>
                                    <li>Arrow functions = this = this of the surrounding function (lexical this) arrows have no this.</li>
                                    <li>Event listener this = DOM element that the handler is attached to.</li>
                                </ul>
                                <h3>'this' does NOT point to the function itself or the variable environment.</h3>
                            </td>
                            <td>The this Keyword</td>
                        </tr>
                        <tr>
                            <td>
                                <span>First class functions</span> is just a feature that a programming language either has or does not have. (There is no such thing in practice) <br>
                                This concept is true for JavaScript as functions return a value and are objects. <br>
                                They are treated as first class citizens. <br><br>

                                <span>Higher Order functions</span> is an actual thing that there is in practice. <br>
                                They are a function that either takes in another function (clickhandler, callback) or one that returns a function (recursive).</td>
                            <td>First-Class function and Higher-Order Functions - What are they?</td>
                        </tr>
                        <tr>
                            <td>
                                <span><u><b>Closure = Variable environment attached to the function, exactly as it is and was at the time of creation.</b></u></span> <br><br>
                                <ul>
                                    <li>A closure gives a function access to all of the variables of its parent function, even after that function has returned. The function keeps reference to its outer scope, which preserves the scope chain throughout time.</li>
                                    <li>A function has access to the variable environment of the execution content in which it was created.</li>
                                    <li>closure has priority over the scope chain! .. Closure has priority over all, it is like a rucksack that carrys round its the variables that were with it when it was born, even after they have moved on.</li>
                                    <li>reassigning functions creates a closure</li>
                                    <li>SetTimeout is a good example of closure. It gets access to the outer Variable environment long after it has gone from the stack.</li>
                                </ul>
                            </td>
                            <td>
                                <b>Closures</b> <br>
                                What is a closure?
                            </td>
                        </tr>
                        <tr>
                            <td>IFFE - are used when we want to execute a function once, <br>
                                they used to be used for encapsulation but no so much anymore since es6 and the introduction of let, const and block scope.</td>
                            <td>IFFEs (Immediately Invoked Function Expressions)</td>
                        </tr>
                    </tbody>
                </table>
            </td>

        </tr>

        <!-- OOP (Object Orientated Programming) -->
        <tr>
            <td>
                <table class="section">
                    <caption>
                        <h3 id="OOP">Object Orientated Programming (OOP)</h3>
                    </caption>
                    <thead>
                        <tr>
                            <td>Code</td>
                            <td>Description</td>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td></td>
                        </tr>
                    </tbody>
                </table>
            </td>

        </tr>

        <!-- Asynchronous JavaScript -->
        <tr>
            <td>
                <table class="section">
                    <caption>
                        <h3 id="async">Asynchronous JavaScript</h3>
                    </caption>
                    <thead>
                        <tr>
                            <td>Code</td>
                            <td>Description</td>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                document.getElementById('button').addEventListener('click', loadData); <br> <br>

                                function loadData(){ <br>
                                &emsp; //Create XHR Object <br>
                                &emsp; const xhr = new XMLHttpRequest(); <br> <br>

                                &emsp; // OPEN <br>
                                &emsp; //(Where we specify the type of request we want to make and the file name), the third
                                parameter is boolean for if we want it to be asynchronous or not; <br>
                                &emsp; xhr.open('GET','data.txt',true); <br>


                                <br>
                                &emsp; // new way readyState jumps straight to 4 <br>
                                &emsp; xhr.onload = function(){ <br>
                                &emsp; if(this.status === 200){ <br>
                                &emsp; &emsp; document.getElementById('output').innerHTML =
                                `&lt;h1>${this.responseText}&lt;/h1>` <br>
                                &emsp; } <br>
                                } <br>
                                <br>
                                &emsp; // Optional -- Used for spinners / loaders - returns readyState - 3; <br>
                                &emsp; xhr.onprogress = function(){ <br>
                                &emsp; <br>
                                &emsp; } <br> <br>

                                &emsp; // We may need to set up better error handling <br>
                                &emsp; xhr.onerror = function(){ <br>
                                &emsp; &emsp; console.log('there was a Request error'); <br>
                                &emsp; } <br> <br>

                                // send <br>
                                xhr.send(); <br> <br>

                                <br>
                                // old way ready state runs through from 1-4. (not used anymore as we now have .onload but
                                may be seen in legacy code) <br>
                                xhr.onreadystatechange = function(){ <br>
                                &emsp; // console.log('READYSTATE', xhr.readyState); here is the check <br>
                                &emsp; if(this.status === 200 & this.readyState === 4){ <br>
                                &emsp; &emsp; console.log(this.responseText); <br>
                                &emsp; } <br>
                                } <br> <br> <br>


                            </td>
                            <td>Ajax / XML HTTP Request</td>
                        </tr>
                        <tr>
                            <td> function createPost(post, callback){ <br>
                                &emsp; setTimeout(function(){ <br>
                                &emsp; &emsp; posts.push(post); <br>
                                &emsp; &emsp; callback(); <br>
                                &emsp; },2000); <br>
                                }
                                <br> <br>

                                function getPosts(){ <br>
                                &emsp; setTimeout(function(){ <br>

                                &emsp; &emsp; let output = ''; <br>

                                &emsp; &emsp; posts.forEach(function(post){ <br>
                                &emsp; &emsp; &emsp; output += `&lt;li>${post.title}&lt;/li>`; <br>

                                &emsp; &emsp; &emsp; document.body.innerHTML = output; <br>
                                &emsp; &emsp; }); <br>

                                &emsp; },1000); <br>
                                } <br> <br>

                                createPost({title: 'Post Three', body: 'This is post 3'}, getPosts);</td>
                            <td>Callback example</td>
                        </tr>
                        <tr>
                            <td> // Get local text file data <br>
                                // here is how to use fetch API, if we were dealing with JSON here we would use res.JSON
                                rather than res.text <br>
                                // you always need to use .then to get the return from the promise. <br>
                                function getText(){ <br>
                                &emsp; fetch('data.txt') <br>
                                &emsp; .then(res => res.text()) <br>
                                &emsp; .then(data => { <br>
                                &emsp; &emsp; console.log(data); <br>
                                &emsp; &emsp; document.getElementById('output').innerHTML = data; <br>
                                &emsp; }) <br>
                                &emsp; &emsp; // here is how we would catch the error if there was one <br>
                                &emsp; .catch(err => console.log(err)); <br>
                                } <br>
                                <br>
                                // Get local json data <br>
                                function getJSON(){ <br>
                                &emsp; fetch('posts.json') <br>
                                &emsp; .then(res => res.json()) <br>
                                &emsp; .then(data =>{ <br>
                                &emsp; &emsp; let output = ''; <br>
                                &emsp; &emsp; data.forEach(post => { <br>
                                &emsp; &emsp; &emsp; output += `&lt;li>${post.title}&lt;/li>`; <br>
                                &emsp; &emsp; }); <br>
                                <br>
                                &emsp; &emsp; document.getElementById('output').innerHTML = output; <br>
                                &emsp; &emsp; console.log(data); <br>
                                &emsp; }) <br>
                                &emsp; // here is how we would catch the error if there was one <br>
                                &emsp; .catch(err => console.log(err) ); <br>
                                }</td>
                            <td>Fetch API example</td>
                        </tr>
                        <tr>
                            <td>
                                async function myFunc() { <br>
                                &emsp; return 'Hello'; <br>
                                } <br><br>

                                myFunc() <br>
                                .then(res => console.log(res));
                            </td>
                            <td>
                                async example
                            </td>
                        </tr>
                        <tr>
                            <td>
                                async function myFunc3() { <br>

                                &emsp; const example_promise = new Promise((resolve, reject) => { <br>
                                &emsp; &emsp; setTimeout(() => resolve('Hello'), 1000); <br>
                                &emsp; }); <br> <br>

                                &emsp; const error = false; <br> <br>

                                &emsp; if(!error){ <br>
                                &emsp; &emsp; // wait until promise is resolved <br>
                                &emsp; &emsp; const res = await example_promise; <br>

                                &emsp; &emsp; return res; <br>
                                &emsp; } <br>
                                &emsp; else{ <br>
                                &emsp; &emsp; await Promise.reject(new Error('Something went wrong')); <br>
                                &emsp; } <br>

                                }
                            </td>
                            <td>
                                async await example
                            </td>
                        </tr>
                        <tr>
                            <td> async function getUsers(){ <br>

                                &emsp; // await the response of the fetch call <br>
                                &emsp; const response = await fetch('https://jsonplaceholder.typicode.com/users'); <br> <br>

                                &emsp; // only process once its resolved <br>
                                &emsp; const answer = await response.json(); <br> <br>

                                &emsp; // only proceed once second promise is resolved. <br>
                                &emsp; return answer; <br>
                                } <br> <br>

                                getUsers() <br>
                                &emsp; .then(users => console.log(users)); <br> <br><br>


                                <br>
                                async function post(url, data) { <br>

                                &emsp; const response = await fetch(url, { <br>
                                &emsp; &emsp; method: 'POST', <br>
                                &emsp; &emsp; headers: { <br>
                                &emsp; &emsp; &emsp; 'Content-type': 'application/json' <br>
                                &emsp; &emsp; }, <br>
                                &emsp; &emsp; body: JSON.stringify(data) <br>
                                &emsp; }); <br> <br>

                                &emsp; const responseData = await response.json(); <br>

                                &emsp; return responseData; <br>

                                } <br>
                                <br>
                                // Create user <br>
                                post('https://jsonplaceholder.typicode.com/users', data) <br>
                                &emsp; .then(data => console.log(data)) <br>
                                &emsp; .catch(err => console.log(err)); <br>

                            </td>
                            <td>Fetch with Async Await</td>
                        </tr>
                        <tr>
                            <td> <u> HTTP Status Codes</u> <br>
                                200 OK <br>
                                400 Bad Request <br>
                                401 Unauthorized <br>
                                404 Not Found <br>
                                500 Internal Server Error <br>

                                <u> readyState Values </u><br>
                                0: Request not initialized <br>
                                1: server connection established <br>
                                2: request received <br>
                                3: processing request <br>
                                4: request finished and response is ready <br></td>
                            <td>HTTP Status Codes & readyState Values </td>
                        </tr>
                    </tbody>
                </table>
            </td>
        </tr>

        <!-- Modules and tooling -->
        <tr>
            <td>
                <table class="section">
                    <caption>
                        <h3 id="modules">Modules and tooling</h3>
                    </caption>
                    <thead>
                        <tr>
                            <td>Code</td>
                            <td>Description</td>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td></td>
                        </tr>
                    </tbody>
                </table>
            </td>

        </tr>

        <!-- JS Browser BOM -->
        <tr>
            <td>
                <table class="section">
                    <caption>
                        <h3 id="BOM">JS Browser BOM</h3>

                    </caption>
                    <thead>
                        <tr>
                            <td>Code</td>
                            <td>Description</td>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>

                                function setCookie(name, value, days) { <br>
                                &emsp; var expires = ""; <br> <br>
                                &emsp; if (days) { <br>
                                &emsp; &emsp; var date = new Date(); <br>
                                &emsp; &emsp; date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000)); <br>
                                &emsp; &emsp; expires = "; expires=" + date.toUTCString(); <br>
                                &emsp; } <br> <br>
                                &emsp; document.cookie = name + "=" + (value || "") + expires + "; path=/"; <br>
                                } <br><br>

                                function getCookie(name) { <br>
                                &emsp; var nameEQ = name + "="; <br><br>
                                &emsp; var ca = document.cookie.split(';'); <br><br>
                                &emsp; for (var i = 0; i < ca.length; i++) { <br>
                                    &emsp; &emsp; var c = ca[i]; <br>
                                    &emsp; &emsp; while (c.charAt(0) == ' ') c = c.substring(1, c.length); <br>
                                    &emsp; &emsp; if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);
                                    <br>
                                    &emsp; } <br> <br>
                                    &emsp; return null; <br>
                                    }

                            </td>
                            <td>Get and set cookies</td>
                        </tr>
                        <tr>
                            <td>
                                <b>
                                    <u> The returned object contains the following properties: </u>
                                </b> <br><br>

                                valid - Is true when the field passes validation. <br> <br>
                                valueMissing - Is true when the field is empty but required. <br><br>
                                typeMismatch - Is true when the field type is email or url but the entered value is not the
                                correct type. <br><br>
                                tooShort - Is true when the field contains a minLength attribute and the entered value is
                                shorter than that length. <br><br>
                                tooLong - Is true when the field contains a maxLength attribute and the entered value is
                                longer than that length. <br><br>
                                patternMismatch - Is true when the field contains a pattern attribute and the entered value
                                does not match the pattern. <br><br>
                                badInput - Is true when the input type is number and the entered value is not a number.
                                <br><br>
                                stepMismatch - Is true when the field has a step attribute and the entered value does not
                                adhere to the step values. <br><br>
                                rangeOverflow - Is true when the field has a max attribute and the entered number value is
                                greater than the max. <br><br>
                                rangeUnderflow - Is true when the field has a min attribute and the entered number value is
                                lower than the min. <br>


                            </td>
                            <td>
                                <br> <u><b>Validity State</b></u> <br>
                                The validity property provides a set of information about a form field, in the form of
                                boolean (true/false) values.<br>
                                We can use it to customize our form validation behavior. <br>
                                Allows us to use the browser’s own field validation algorithms in our scripts instead of
                                writing our own.
                            </td>
                        </tr>

                        <tr>
                            <td>
                                let d = new Date(Date.parse("2020-12-26T17:13:10+01:00")); <br><br>
                                document.getElementById("demo").innerHTML = d;
                            </td>
                            <td>Convert and format Time and Date</td>
                        </tr>
                    </tbody>
                </table>
            </td>
        </tr>

        <!-- Regular Expressions -->
        <tr>
            <td>
                <table class="section">
                    <caption>
                        <h3 id="regEX">Regular Expressions</h3>
                    </caption>
                    <thead>
                        <tr>
                            <td>Code</td>
                            <td>Description</td>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                <b><u> for console</u> </b>
                                // String to match <br>
                                const str = 'Enter String in here!';<br>
                                <br>
                                // Log results<br>
                                const result = re.exec(str);<br>
                                console.log(result);<br>
                                <br>

                                function reTest(re, str){<br>
                                &emsp; if(re.test(str)){<br>
                                &emsp; &emsp; console.log(`${str} matches ${re.source}`);<br>
                                &emsp; }<br>
                                &emsp; else{<br>
                                &emsp; &emsp; console.log(`${str} does not match ${re.source}`);<br>
                                &emsp; }<br>
                                }<br>

                                console.log(reTest(re, str));

                                <br><br>
                                <b><u> for production, bootstrap error here,</u> </b> <br>
                                function validateName(){ <br>
                                &emsp; const name = document.getElementById('name'); <br> <br>
                                &emsp; const re = /^[a-zA-Z]{2,10}$/; <br> <br>

                                &emsp; if(!re.test(name.value)){ <br>
                                &emsp; &emsp; name.classList.add('is-invalid'); <br>
                                &emsp; } <br>
                                &emsp; else{ <br>
                                &emsp; &emsp; name.classList.remove('is-invalid'); <br>
                                &emsp; } <br>
                                }
                                <br>
                            </td>

                            <td>
                                RegEX - Testing function
                            </td>
                        </tr>
                        <tr>
                            <td>let re = /hello/; <br>
                                let re = /hello/i; - case insensitive <br>
                                let re = /hello/g; - global search that will not just stop at the first match.<br> <br>


                                re.source = hello; <br> <br>

                                <b>exec()</b> &emsp; - Returns result in array or null; <br>
                                console.log( re.exec('hello world') ); <br> <br>

                                <b>test()</b> &emsp; - Returns true or false <br>
                                console.log( re.test('Hello') ); <br><br>

                                <b>match()</b> &emsp;- Return result array or null <br>
                                const str = 'Hello there'; <br>
                                console.log( str.match(re) ); <br> <br>
                                Here is how it would return if the search was case insensitive. <br>
                                ["hello", index: 0, input: "hello there", groups: undefined] <br><br>

                                <b>search()</b> &emsp; - Returns index of the first match, if not found it returns -1 <br>
                                const str = 'Matthew Hello there'; <br>
                                console.log( str.search(re) ); <br> <br>

                                <b>replace()</b> &emsp; - Return new string with some or all matches of a pattern.<br>
                                const str = 'Hello There'; <br>
                                const newStr = str.replace('re','Hi'); <br>
                                console.log(newStr);
                            </td>
                            <td>RegEX - Evaluation Functions</td>
                        </tr>
                        <tr>
                            <td>
                                re = /^h/i; // ^ = Must start with <br> <br>

                                re = /world$/i; // $ = Must end with <br> <br>

                                re = /^world$/i; // Must begin and end with <br> <br>

                                re = /h.llo/i; // Matches any ONE Character, The dot is like a wildcard but for only one character, <br>
                                <br>

                                re = /h*llo/i; // Matches any Character, This is true wildcard very dangerous when used like this, <br> <br>

                                re = /gre?a?y/i; // Optional, character can be a,e or empty here <br> <br>

                                re = /gre?a?y\?/i; // Escape characters, we do this with the backslash. <br> <br>

                            <td>RegEx - Metacharacter Symbols</td>
                        </tr>

                        <tr>
                            <td>
                                <b><u> Brackets [] - Character sets </u> </b> <br>
                                re = /gr[ae]y/i; // Must be an 'a' or 'e' , better than the escape character above. <br>
                                <br>
                                re = /[GF]ray/; // Must be an 'G' or 'F' <br>
                                <br>
                                re = /[^GF]ray/; // Match anything apart from a 'G' or 'F', *** totally different to the start with as it is
                                inside the brackets. *** <br>
                                <br>
                                re = /[A-Z]ray/; // Match any uppercase letter <br>
                                <br>
                                re = /[A-Za-z]ray/; // Match any letter
                                <br>
                                re = /[0-9][0-9]ray/; // Match any number <br>
                                <br>
                                <br>
                                <b><u> Braces {} - Quantifiers </u> </b> <br>
                                re = /Hel{2}o/i; //Must occur exactly {m} amount of times, - Must be 2 'l' characters <br>
                                <br>
                                re = /[0-9]{3,5}ray/; // Must be 3-5 digits then ray, same as above but with range <br>
                                <br>
                                re = /[0-9]{3,}ray/; // Must occur {m,} 3, or more times <br>
                                <br> <br>
                                <b><u> Parenthesis () - Grouping </u> </b> <br>
                                re = /([0-9]x){3}/; // Must be number x number x number x 9x9x9x <br>
                            </td>
                            <td>
                                RegEx - Character Sets & Quantifiers
                            </td>

                        </tr>
                        <tr>
                            <td> <b><u> Shorthand Character Classes </u> </b> <br>
                                re = /\w/ // Word character, can be alphanumeric or '_' underscore. <br>
                                <br>
                                re = /\w+/ // + = 1 or more <br>
                                <br>
                                re = /\W/ // NON-Word character, match anything that is not alphanumeric (uppercase W)<br>
                                <br>
                                re = /\d/ // Match any digit<br>
                                <br>
                                re = /\d+/ // Match any digit 1 or more times<br>
                                <br>
                                re = /\D/ // Match any NON digit (uppercase D)<br>
                                <br>
                                re = /\s/ // Match whitespace character.<br>
                                <br>
                                re = /\S/ // Match NON whitespace character.<br>
                                <br>
                                re = /Hell\b/i // Word Boundary, Matches whole world instead of just everytime when it finds 'hell' eg
                                'Hello'.<br>
                                <br>
                                <b><u> Assertions </u> </b> <br>
                                re = /x(?=y)/; // Match x only if followed by y<br>
                                <br> re = /x(?!y)/; // Match x only if NOT followed by y
                            </td>
                            <td>Shorthand Character Classes & Assertions</td>
                        </tr>
                        <tr>

                            <td>
                                <span>Hard Password</span> <br>
                                &lt;input type="password" pattern="^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?!.*\s).*$" required <br> title="Please
                                include at least 1 uppercase character, 1 lowercase character, and 1 number.">
                                <br> <br>
                                <span>Validating Numbers</span> <br>
                                &lt;input type="number" pattern="[-+]?[0-9]" step="any">
                                <br><br>

                                <span>email</span><br>
                                &lt;input type="email" title="The domain portion of the email address is invalid (the portion after the @)."
                                <br>
                                pattern="^([^\x00-\x20\x22\x28\x29\x2c\x2e\x3a-\x3c\x3e\x40\x5b-\x5d\x7f-\xff]+|\x22([^\x0d\x22\x5c\x80-\xff]|\x5c[\x00-\x7f])*\x22)<br>
                                (\x2e([^\x00-\x20\x22\x28\x29\x2c\x2e\x3a-\x3c\x3e\x40\x5b-\x5d\x7f-\xff]+|\x22([^\x0d\x22\x5c\x80-\xff]|\x5c[\x00-\x7f])*\x22))*\x40<br>
                                ([^\x00-\x20\x22\x28\x29\x2c\x2e\x3a-\x3c\x3e\x40\x5b-\x5d\x7f-\xff]+|\x5b([^\x0d\x5b-\x5d\x80-\xff]|\x5c[\x00-\x7f])*\x5d)(\x2e([^\x00-\x20<br>\x22\x28\x29\x2c\x2e\x3a-\x3c\x3e\x40\x5b-\x5d\x7f-\xff]+|\x5b([^\x0d\x5b-\x5d\x80-\xff]|\x5c[\x00-\x7f])*\x5d))*(\.\w{2,})+$">
                                <br><br>

                                <span>URL</span><br>
                                &lt;input type="url" title="The URL is a missing a TLD (for example, .com)."<br>
                                pattern="^(?:(?:https?|HTTPS?|ftp|FTP):\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)<br>(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]<br>|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:<br>[a-zA-Z\u00a1-\uffff0-9]-*)*[a-zA-Z\u00a1-\uffff0-9]+)(?:\.(?:[a-zA-Z\u00a1-\uffff0-9]-*)*[a-zA-Z\u00a1-\uffff0-9]+)*(?:\.(?:[a-zA-Z\u00a1-<br>\uffff]{2,}))\.?)(?::\d{2,})?(?:[/?#]\S*)?$">
                                <br><br>

                                <span>Dates</span> <br>
                                &lt;input type="date"
                                pattern="(?:19|20)[0-9]{2}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-9])|(?:(?!02)(?:0[1-9]|1[0-2])-(?:30))|(?:(?:0[13578]|1[02])-31))">
                                <br><br>

                                <span>Time</span> <br>
                                &lt;input type="time" pattern="(0[0-9]|1[0-9]|2[0-3])(:[0-5][0-9])">
                                <br><br>

                                <span>Month</span> <br>
                                &lt;input type="month" pattern="(?:19|20)[0-9]{2}-(?:(?:0[1-9]|1[0-2]))">
                                <br><br>

                                <span>Fullname pattern take away slashes for HTML</span> <br>
                                /^[a-zA-Z]+( [a-zA-Z]+)+$/
                                <br><br>

                                <span>Postcode Pattern</span><br>
                                /(GIR
                                0AA)|((([ABCDEFGHIJKLMNOPRSTUWYZ][0-9][0-9]?)|(([ABCDEFGHIJKLMNOPRSTUWYZ][ABCDEFGHKLMNOPQRSTUVWXY][0-9][0-9]?)|(([ABCDEFGHIJKLMNOPRSTUWYZ][0-9][ABCDEFGHJKSTUW])|([ABCDEFGHIJKLMNOPRSTUWYZ][ABCDEFGHKLMNOPQRSTUVWXY][0-9][ABEHMNPRVWXY]))))
                                [0-9][ABDEFGHJLNPQRSTUWXYZ]{2})/

                            <td>Form Validation</td>
                        </tr>
                    </tbody>
                </table>
            </td>
        </tr>


        <!-- Error Handling -->
        <tr>
            <td>
                <table class="section">
                    <caption>
                        <h3 id="error-handling">Error Handling</h3>
                    </caption>
                    <thead>
                        <tr>
                            <td>Code</td>
                            <td>Description</td>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                try{ <br>
                                &emsp; // Produce a ReferenceError as function doesnt exist <br>
                                &emsp; myFunction(); <br> <br>

                                &emsp; // Produce a TypeError <br>
                                &emsp; null.myFunction(); <br> <br>

                                &emsp; // Will Produce a SynyaxError <br>
                                &emsp; eval('Hello world'); <br> <br>

                                &emsp; // Will Produce a URIError <br>
                                &emsp; decodeURICompnent(%); <br> <br>

                                // How to create our own errors with throw,
                                if(!Something.Something){
                                &emsp; // we can do it this way <br>
                                &emsp; throw 'The Something is broken'; <br> <br>

                                &emsp; //Or we can do it this way with specific error type<br>
                                &emsp; throw new SyntaxError('Something does not exist');
                                }


                                } <br> <br>
                                catch(e){ <br>
                                &emsp; console.log(`User Error: `${e.message}); <br>
                                &emsp; console.log(e.message); <br>
                                &emsp; console.log(e.name); <br>
                                &emsp; console.log(e instanceof TypeError); <br>
                                } <br> <br>
                                finally{ <br>
                                &emsp; console.log('Finally runs regardless of the result. as is optional.')<br>
                                }<br> <br>
                                console.log('programme continues... rather than stop due to the error.');
                            </td>
                            <td>Error Handling with try / catch. </td>
                        </tr>
                        <tr>
                            <td>

                            </td>
                        </tr>
                    </tbody>
                </table>
            </td>
        </tr>

        <!-- Handy / Other -->
        <tr>
            <td>
                <table class="section">
                    <caption>
                        <h3 id="handy">Handy / OTHER </h3>
                    </caption>
                    <thead>
                        <tr>
                            <td>Code</td>
                            <td>Description</td>
                        </tr>
                    </thead>
                    <tbody>

                        <tr>
                            <td>
                                <span>'use strict'</span>
                                Use strict mode at the beginning of our script before all of the other code else it will not work. <br><br>

                                We can also use it in each function, but is easier to just include it for the whole page. <br><br>

                                Note: Sometimes you'll see the default, non-strict mode referred to as "sloppy mode". This isn't an official term, but be aware of it, just in case. <br><br>
                                Strict mode makes several changes to normal JavaScript semantics:
                                <ol>
                                    <li>Eliminates some JavaScript silent errors by changing them to throw errors.</li>
                                    <li>
                                        Fixes mistakes that make it difficult for JavaScript engines to perform optimizations: strict mode code can sometimes be made to run faster than identical code that's not strict mode.</li>
                                    <li>Prohibits some syntax likely to be defined in future versions of ECMAScript.</li>
                                </ol>
                            </td>
                            <td>Activating Strict Mode </td>
                        </tr>
                        <tr>
                            <td>
                                const rest1 = { <br>
                                name: 'Capri', <br>
                                numGuests: 0,<br>
                                };
                                <br> <br>
                                const rest2 = {<br>
                                name: 'La Plazza',<br>
                                owner: 'Will Rossi'<br>,
                                };<br><br>

                                //// OR assignment operator. (does not work like this if comparing to 0 as 0 = falsy)<br>
                                // rest1.numGuests = rest1.numGuests || 10;<br>
                                // rest2.numGuests = rest2.numGuests || 10;<br>
                                <br>
                                <br> //// new logical assignment operator. ES2021 (does not work like this if comparing to 0 as 0 = falsy)<br>
                                // rest1.numGuests ||= 10;<br>
                                // rest2.numGuests ||= 10;<br> <br>

                                <br> //// We should use the nullish assignment operator if we are comparing to 0. as it will not set 0 to falsy and will only set null or undefined to false)<br>
                                rest1.numGuests ??= 10;<br>
                                rest2.numGuests ??= 10;<br> <br>
                                ?? works like the || but only short circuits with null or undefined, it will not short circuit with 0 or " " empty string

                                <br><br>
                                <span>use optional chaining and the nullish coalescing operators together.</span><br>

                                console.log(restaurant.orderRissoto?.(0, 2) ?? 'Method does not exist.'); <br>

                                console.log(users[0]?.name ?? 'User array empty'); <br><br>
                                <u>Another Example</u> <br>
                                // register answer (&& keeps going till a condition is false) <br>
                                typeof answer === 'number' && answer < this.options.length && this.answers[answer]++; <br><br><br>
                                    <b>The assignment operator works from <span>right to left</span> so we are able to clear 2 fields at the same time <br>
                                        or set multiple values when we want the to be the same instead of writing multiple lines of code. </b><br> <br>
                                    Here is an example inputLoginUsername.value = inputLoginPin.value = ' '; <br><br>

                                    It will start by assigning the empty string to inputLoginPin.value to ' '/ the empty string. next it will assign inputLoginPin.value which now = ''/empty string to inputLoginUsername.value.
                            </td>
                            <td>
                                Short circuiting && Nullish assignment operator ??

                            </td>
                        </tr>
                        <tr>
                            <td>switch (true) {
                                case liCount == 0:
                                setLayoutState('start');
                                var api = $('#UploadList').data('jsp');
                                api.reinitialise();
                                break;
                                case liCount<=5 && liCount>0:
                                    setLayoutState('upload1Row');
                                    var api = $('#UploadList').data('jsp');
                                    api.reinitialise();
                                    break;
                                    case liCount<=10 && liCount>5:
                                        setLayoutState('upload2Rows');
                                        var api = $('#UploadList').data('jsp');
                                        api.reinitialise();
                                        break;
                                        case liCount>10:
                                        var api = $('#UploadList').data('jsp');
                                        api.reinitialise();
                                        break;
                                        }
                                        The only thing necessary is switch(true){...} and for your case expressions to evaluate to booleans.</td>
                            <td>Using switch over if else to evaluate to booleans. <br>
                                Use with caution, because it is a non-standard pattern, despite being valid code.</td>
                        </tr>
                        <tr>
                            <td>dont forget which side to put the index++ or ++index when working inside functions/ callbacks/ for / loops / </td>
                            <td>index++ or ++index</td>
                        </tr>
                        <tr>
                            <td>
                                Whenever we call a method on a string, JavaScript will behind the scenes convert the string primitive into a string object so that we can use methods on it. This is process called boxing. <br>
                                As it takes our string and puts it into the box which is the object. it calls the new String('string'); function <br><br>
                                strings can NOT be mutated as they are primitive! we must store the data into a new variable.
                                <br><br><br>
                                We can not use splice on a string as it is destructive, we must use slice instead as it does not manipulate the original string.
                                <br> <br><br>
                            </td>
                            <td>
                                <ul>strings</ul> <br>
                                What happens when we call a method on a string (boxing).
                            </td>
                        </tr>
                        <tr>
                            <td>
                                A single vibration <br>
                                window.navigator.vibrate(200); <br><br>

                                Vibration patterns <br>
                                An array of values describes alternating periods in which the device is vibrating and not
                                vibrating. <br>
                                window.navigator.vibrate([200, 100, 200]);
                                <br>

                            </td>
                            <td>Vibration API</td>
                        </tr>
                        <tr>
                            <td>
                                typeof null === 'object <br>
                                typeof undefined === 'undefined'
                                <br><br>
                                null !== undefined but null == undefined<br><br>

                                <span>Also worth remembering</span>
                                <br>
                                var foo = 'bar;<br>
                                ...<br>
                                delete foo <br>
                                console.log(typeof foo)<br>

                                <span>will cause foo to become undefined, not null</span>
                                <br><br>
                                Consider <span>undefined</span> to represent a system level <span>unexpected absence of value</span> <br> <br>
                                Consider <span>null</span> to represent a system level <span>normal expected absence of value</span> <br>
                            </td>
                            <td>The difference between null and undefined</td>
                        </tr>
                        <tr>
                            <td>the ! (NOT) operator has precedence over the && , ||</td>
                            <td>Boolean logic</td>
                        </tr>
                        <tr>
                            <td>
                                <ol>
                                    <li>Understand the problem</li>
                                    <li>Then break into sub problems.</li>
                                </ol>

                                <br>
                                Use <a target="_blank" href="https://diagrams.net">diagrams.net</a> for creating good flow charts when building apps
                            </td>
                            <td>
                                Problem solving and project planning
                            </td>
                        </tr>
                    </tbody>
                </table>
            </td>
        </tr>

</body>

</html>